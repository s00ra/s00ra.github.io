[{"content":"Twilight We encountered an image that contained some unkown characters. To analyze the cipher, I utilized the Symbols Cipher List on the dcode.fr website. It was determined that the cipher was the Hylian Language.\nDecrypting the cipher yielded the following text: REVWALJHEHIDDWNPLAINSWCRWJMESSADE. By making slight adjustments to the text,\n1 2 print(\u0026#34;REVWALJHEHIDDWNPLAINSWCRWJMESSADE\u0026#34;.replace(\u0026#34;W\u0026#34;, \u0026#34;E\u0026#34;).replace(\u0026#34;J\u0026#34;, \u0026#34;T\u0026#34;)) # and replace the last D in MESSADE with G Flag: EGCERT{REVEALTHEHIDDENPLAINSECRETMESSAGE} Simple Cipher Challenge 1 2 3 4 5 6 7 8 9 10 11 import os FLAG = open(\u0026#34;flag.txt\u0026#34;, \u0026#34;rb\u0026#34;).read() KEY = os.urandom(FLAG.index(b\u0026#34;{\u0026#34;)+1) def xor(plain): enc = b\u0026#34;\u0026#34; for i, c in enumerate(plain): enc += int.to_bytes(c ^ KEY[i % len(KEY)]) return enc.hex() print(xor(FLAG)) # out: 61bade96f3f7f36d90c29b92d1bb7b8aa9ba9692e61da2c9e3fefbb876dce0 Solution The challenge uses XOR encryption alogrithm and a 7-byte key length. It loop through the plaintext and encrypting the first 7 bytes, then repeating the key from the beginning.\nXOR is commutative means that aâŠ•b = bâŠ•a. XOR is associative means that aâŠ•(bâŠ•c) = (aâŠ•b)âŠ•c = (aâŠ•c)âŠ•b. If the plaintext was this_is_test and the key is key so the operation would be like this_is_test âŠ• keykeykeykey The key length matching the length of the flag format, which is EGCERT{. Therefore, we can XOR the first 7 characters of the cipher with the flag format to obtain the key.\n1 2 3 4 5 from pwn import xor out = bytes.fromhex(\u0026#34;61bade96f3f7f36d90c29b92d1bb7b8aa9ba9692e61da2c9e3fefbb876dce0\u0026#34;) known = b\u0026#34;EGCERT{\u0026#34; key = xor(out[:7], known) print(xor(out, key)) Flag: EGCERT{Im_H3r3_w4i71n9_T0_X0R!} Easy Encryption Challenge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from gmpy2 import next_prime from Crypto.Util.number import getPrime,bytes_to_long from random import randint import os from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/start/\u0026#39;) def decrypt(): flag = os.environ.get(\u0026#34;CTF_FLAG\u0026#34;, \u0026#34;EGCTF{FAKE_FLAAAAAAAAAAAAG}\u0026#34;) m1 = bytes_to_long(flag[:len(flag)//2]) m2 = bytes_to_long(flag[len(flag)//2:]) e = 0x10001 z = getPrime(512) p1 = getPrime(512) q1 = next_prime(p1) n1 = p1*q1 p2 = next_prime(q1) q2 = next_prime(p2) n2 = p2*q2 n3 = n1 * n2 n4 = q1 * getPrime(1024) c1 = (z * pow(m1,e,n3)) % n3 c2 = (m1*randint(1000,30000) * pow(m2,e,n4)) % n4 return {\u0026#39;n1\u0026#39;:int(n3) , \u0026#39;n2\u0026#39;:int(n4), \u0026#39;c1\u0026#39;:int(c1), \u0026#39;c2\u0026#39;:int(c2), \u0026#39;z\u0026#39;:int(z), \u0026#39;e\u0026#39;:int(e)} @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;Hi!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run() Solution It took me too much time, nearly 1H, until i reialized that he sent n3, n4 instead of n1, n2 ðŸ˜‚ðŸ˜‚.\nLet\u0026rsquo;s see, we have two equations\nc1 = (z * pow(m1, e, n3)) % n3\rc2 = (m1 * randint(1000,30000) * pow(m2, e, n4)) % n4\rlet\u0026rsquo;s find a starting point, if look at app.py we will notice that\nn3 = n1 * n2 = = p1 * q1 * p2 * q2\rn4 = q1 * RandomPrime\rS0o0, n3 and n4 have a common factor which is q1. We can use Common Prime Attack to retrieve factors of the moduli.\nIf N1 and N2 have a common factor that is mean GCD(N1, N2) != 1 We can calculate P as the following p = GCD(N1, N2), q1 = N1 // p, and q2 = N2 // p 1 2 3 4 5 6 7 8 9 10 import requests import json vals = json.loads(requests.get(\u0026#34;http://209.38.200.9:7715/start/\u0026#34;).text) n3, n4, c1, c2, z, e = vals[\u0026#39;n1\u0026#39;], vals[\u0026#39;n2\u0026#39;], vals[\u0026#39;c1\u0026#39;], vals[\u0026#39;c2\u0026#39;], vals[\u0026#39;z\u0026#39;], vals[\u0026#39;e\u0026#39;] n1 = GCD(n3, n4) n2 = n3 // n1 n4_rand = n4 // n1 # print(n1 * n2 == n3) # print(n4_rand * n1 == n4, isPrime(n4_rand), isPrime(n1)) Now we have n3 and n4 factors if we can get pow(m1, e, n3) and pow(m2, e, n4) then it will be easy to solve ðŸ™‚. Wait actuall we can !\nWe can retrieve pow(m1, e, n3) easily using Modular Division\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m # pow_m1_e_n3 = (c1 * inverse(z, n3)) % n3 pow_m1_e_n3 = modDivide(c1, z, n3) phi = (n1 - 1) * (n2 - 1) d = inverse(e, phi) m1 = pow(pow_m1_e_n3, d, n1) # EGCERT{16500bc003f74b4ba6ef96 Now doing the same with pow(m2,e,n4), but we just need to brute force the RandomNumber randint(1000,30000)\n1 2 3 4 5 6 7 8 9 10 11 12 13 # randint(1000,30000) * pow(m2,e,n4) rand_mul_pow_m2_e_n4 = modDivide(c2, m1, n4) for i in range(1000, 30000+1, 1): pow_m2_e_n4 = modDivide(rand_mul_pow_m2_e_n4, i, n4) phi = (n4_rand - 1) * (n1 - 1) d = inverse(e, phi) m2 = pow(pow_m2_e_n4, d, n4) if len(long_to_bytes(m2)) \u0026lt; 50: print(long_to_bytes(m2)) exit() Full code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import requests import json from Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime # from sage.all import * def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m \u0026#39;\u0026#39;\u0026#39; c1 = (z * pow(m1,e,n3)) % n3 c2 = (m1 * randint(1000,30000) * pow(m2,e,n4)) % n4 \u0026#39;\u0026#39;\u0026#39; vals = json.loads(requests.get(\u0026#34;http://209.38.200.9:7715/start/\u0026#34;).text) n3, n4, c1, c2, z, e = vals[\u0026#39;n1\u0026#39;], vals[\u0026#39;n2\u0026#39;], vals[\u0026#39;c1\u0026#39;], vals[\u0026#39;c2\u0026#39;], vals[\u0026#39;z\u0026#39;], vals[\u0026#39;e\u0026#39;] n1 = GCD(n3, n4) n2 = n3 // n1 n4_rand = n4 // n1 # print(n1 * n2 == n3) # print(n4_rand * n1 == n4, isPrime(n4_rand), isPrime(n1)) # pow_m1_e_n3 = (c1 * inverse(z, n3)) % n3 pow_m1_e_n3 = modDivide(c1, z, n3) phi = (n1 - 1) * (n2 - 1) d = inverse(e, phi) # EGCERT{16500bc003f74b4ba6ef96 m1 = pow(pow_m1_e_n3, d, n1) # randint(1000,30000) * pow(m2,e,n4) rand_mul_pow_m2_e_n4 = modDivide(c2, m1, n4) for i in range(1000, 30000+1, 1): pow_m2_e_n4 = modDivide(rand_mul_pow_m2_e_n4, i, n4) phi = (n4_rand - 1) * (n1 - 1) d = inverse(e, phi) m2 = pow(pow_m2_e_n4, d, n4) if len(long_to_bytes(m2)) \u0026lt; 100: print(long_to_bytes(m2)) exit() print(\u0026#34;Failed\u0026#34;) Bad Mode Challenge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from flask import Flask import os from Crypto.Util.Padding import pad from Crypto.Cipher import AES import codecs KEY = os.urandom(16) app = Flask(__name__) @app.route(\u0026#39;/decrypt/\u0026lt;ciphertext\u0026gt;/\u0026#39;) def decrypt(ciphertext): ciphertext_bytes = codecs.decode(ciphertext, \u0026#34;hex\u0026#34;) decrypted = AES.new(KEY, AES.MODE_CBC, KEY).decrypt(ciphertext_bytes) return codecs.encode(decrypted, \u0026#34;hex\u0026#34;).decode() @app.route(\u0026#39;/encrypt/\u0026lt;plaintext\u0026gt;/\u0026#39;) def encrypt(plaintext): plaintext_bytes = codecs.decode(plaintext, \u0026#34;hex\u0026#34;) encrypted = AES.new(KEY, AES.MODE_CBC, KEY).encrypt(plaintext_bytes) return codecs.encode(encrypted, \u0026#34;hex\u0026#34;).decode() @app.route(\u0026#39;/check_key/\u0026lt;user_key\u0026gt;/\u0026#39;) def check_key(user_key): FLAG = os.environ.get(\u0026#34;FLAG\u0026#34;) FLAG = pad(FLAG.encode(), 16) user_key_bytes = codecs.decode(user_key, \u0026#34;hex\u0026#34;) return codecs.encode(FLAG, \u0026#34;hex\u0026#34;).decode() if user_key_bytes == KEY else \u0026#34;Try Again !!\u0026#34; @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;Hi!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run() Solution Using the key as an IV is insecure; an attacker that can modify ciphertext in flight can get the receiver to decrypt a value that will reveal the key. [Here you can find a better explanation]\nencrypt the message that is at least 3 blocks long AES-CBC(P_1, P_2, P_3) -\u0026gt; C_1, C_2, C_3 Modify the message (you are now the attacker) C_1, C_2, C_3 -\u0026gt; C_1, 0, C_1 Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found. As the attacker, recovering the plaintext from the error, extract the key: P\u0026rsquo;_1 XOR P\u0026rsquo;_3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import requests import json from Crypto.Util.number import bytes_to_long url = \u0026#34;http://209.38.200.9:7710/\u0026#34; def decrypt(cipher): new_url = url + \u0026#34;decrypt\u0026#34; + \u0026#34;/\u0026#34; + cipher + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text def encrypt(plaintext): new_url = url + \u0026#34;encrypt\u0026#34; + \u0026#34;/\u0026#34; + plaintext + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text def check_key(key): new_url = url + \u0026#34;check_key\u0026#34; + \u0026#34;/\u0026#34; + key + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text # any plaintext plaintext = (b\u0026#39;a\u0026#39;*(16*3)).hex() # decrypt the plaintext # we get c1 -\u0026gt; c2 -\u0026gt; c3 response_cipher = encrypt(plaintext) response_cipher = json.loads(response_cipher) cipher = response_cipher[\u0026#39;ciphertext\u0026#39;] # Modify the message # C_1, C_2, C_3 -\u0026gt; C_1, 0, C_1 fake_cipher = cipher[:32] + \u0026#39;0\u0026#39;*32 + cipher[:32] # we get the fake plaintext response_plain = decrypt(fake_cipher) response_plain = json.loads(response_plain) fake_plain = bytes.fromhex( response_plain[\u0026#39;error\u0026#39;][19:] ) # the length of fake_plain is 48 # As the attacker, recovering the plaintext from the error, extract the key: # P\u0026#39;_1 XOR P\u0026#39;_2 iv = [0]*16 for i in range(len(iv)): iv[i] = fake_plain[i] ^ fake_plain[32+i] key = bytes(iv).hex() response_flag = check_key(key) response_flag = json.loads(response_flag) Sign Gate RSA has a homomorphic property. First, we need to understand what homomorphic means and how we can utilize this property to sign our message\nWhat is homomorphic encryption It\u0026rsquo;s property that allows performing certain operations on encrypted data, resulting in equivalent operations on the plaintext when decrypted.\nMultiplicative homomorphism specifically means that given the encrypted values of two plaintexts, it is possible to compute the encryption of their product without decrypting them.\nRSA, does not possess full multiplicative homomorphism. However, it does have a limited form of homomorphic property with respect to multiplication.\nHow we can utilize this The rules of exponents say that (a)n * (b)n = (ab)n. This means that multiplying two ciphertexts encrypted with the same key is equivalent to raising the product of the plaintexts to the power of the secret key. Therefore, RSA is multiplicatively homomorphic. [1]\nc1c2 mod N = m1dm2d mod N = (m1m2)d mod N\r1 2 3 4 5 6 7 8 9 10 11 from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, inverse, long_to_bytes key = RSA.generate(2048) msg1 = bytes_to_long(b\u0026#34;this_is_msg_1\u0026#34;); msg2 = bytes_to_long(b\u0026#34;test\u0026#34;) enc1 = pow(msg1, key.e, key.n); enc2 = pow(msg2, key.e, key.n) # first multiplying two ciphers cipher_product = (enc1 * enc2) % key.n # encrypt the cipher_product with the same key == product of two msgs print(pow(cipher_product, key.d, key.n) == msg1 * msg2) Think\rSolution\rThink Now Think about it, how can we sign our msg ðŸ¤”?\rSolution We need to get a msg_enc = pow(b'Crypt0N19h7'), d, n) but the server will not accept our msg s0o0oo, if we for example sign msg+b'\\x00' which is bytes_to_long(msg)*256 we will have msg_mul_256_enc = pow(bytes_to_long(b'Crypt0N19h7\\x00'), e, n) and sign (256), num_256_enc = pow((256), e, n)\nmsg_mul_256_enc = pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\\x00\u0026rsquo;), e, n) = pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\u0026rsquo;) * 256, e, n)\nnum_256_enc = pow((256), e, n)\nWe can get pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\u0026rsquo;), e, n) using modular multiplicative inverse\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * import ast from Crypto.Util.number import bytes_to_long, inverse def sign_msg(n): r.sendline(b\u0026#34;1\u0026#34;) r.recvuntil(b\u0026#39;Enter message to sign: \u0026#39;) r.sendline(str(n).encode()) val = int(r.recvuntil(b\u0026#39;=\u0026gt; \u0026#39;)[:-4].decode()) return val def check(n): r.sendline(b\u0026#34;2\u0026#34;) r.recvuntil(b\u0026#39;Enter signature to verify: \u0026#39;) r.sendline(str(n).encode()) print(r.recvline()) print(r.recvline()) def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m r = remote(\u0026#39;209.38.200.9\u0026#39;, 7725) x = r.recvuntil(b\u0026#39;=\u0026gt; \u0026#39;) pub_key = ast.literal_eval(x[x.find(b\u0026#34;(\u0026#34;):x.find(b\u0026#34;)\u0026#34;)+1].decode()) n, e = pub_key[0], pub_key[1] msg = bytes_to_long(b\u0026#34;Crypt0N19h7\u0026#34;) msg *= 256 # msg = b\u0026#39;Crypt0N19h7\\x00\u0026#39; msg_mul_256 = sign_msg(msg) sign_256 = sign_msg(256) msg_sign = modDivide(msg_mul_256, sign_256, n) check(msg_sign) Parameter Injection We are allowed to send the parameters A, g, and p to Bob. This enables us to send a smooth number p, which allows us to apply the Pohlig-Hellman Attack.\nWhat is smooth number\rWhat is Pohlig-Hellman Attack\rWhat is smooth number Smooth number is a number which can be written from small prime factors. Smooth number must be a prime so that we can use Pohlig-Hellman Attack, the use of a smooth prime is a crucial step in efficiently computing the discrete logarithm.\rWhat is Pohlig-Hellman Attack In the Pohlig-Hellman Attack, we aim to compute the discrete logarithm of a given value. Let\u0026rsquo;s say we have a generator g, a prime modulus p, and a public value A such that A â‰¡ g^a (mod p) for some unknown private exponent a.\nIt factoring the smooth prime p-1 into its prime factors. Let\u0026rsquo;s denote these prime factors as p_1, p_2, ..., p_k. For each prime factor p_i, we compute a partial discrete logarithm x_i using the Chinese Remainder Theorem (CRT) method.\nBy applying the CRT to the partial discrete logarithms, we can reconstruct the full discrete logarithm a modulo p-1. Once we have a, we can compute the shared secret key.\nThe use of a smooth prime* allows us to efficiently compute the partial discrete logarithms and apply the CRT to reconstruct the full discrete logarithm.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrime, getPrime from sympy.ntheory.residue_ntheory import discrete_log from Crypto.Util.Padding import pad, unpad from Crypto.Cipher import AES import hashlib import json from pwn import * def repeat(n): x = 1 for i in range(n): x *= getPrime(32) return x*2+1 def create_weak_prime(n): while True: x = repeat(n) if isPrime(x): print(x) break def decrypt_flag(shared_secret, iv, ciphertext): key = hashlib.sha1(str(shared_secret).encode()).hexdigest()[:16].encode() cipher = AES.new(key, AES.MODE_CBC, bytes.fromhex(iv)) decrypted_data = cipher.decrypt(bytes.fromhex(ciphertext)) plaintext = unpad(decrypted_data, 16).decode() return plaintext conn = remote(\u0026#39;209.38.200.9\u0026#39;, 7720) conn.recvuntil(b\u0026#34;Intercepted from Alice: \u0026#34;) alice = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) p = alice[\u0026#39;p\u0026#39;] g = alice[\u0026#39;g\u0026#39;] A = alice[\u0026#39;A\u0026#39;] conn.recvuntil(b\u0026#34;Intercepted from Bob: \u0026#34;) bob = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) B = bob[\u0026#39;B\u0026#39;] conn.recvuntil(b\u0026#34;Intercepted from Alice: \u0026#34;) alice_iv = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) iv = alice_iv[\u0026#39;iv\u0026#39;] encrypted_flag = alice_iv[\u0026#39;encrypted\u0026#39;] fake_p = create_weak_prime(64) val = json.dumps({\u0026#34;p\u0026#34;:fake_p, \u0026#34;g\u0026#34;:g, \u0026#34;A\u0026#34;:A}) conn.recvuntil(b\u0026#34;Bob connects to you, send him some parameters:\\n\u0026#34;) conn.sendline(val.encode()) conn.recvuntil(b\u0026#34;Bob says to you: \u0026#34;) bob2 = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) B2 = bob2[\u0026#39;B\u0026#39;] \u0026#39;\u0026#39;\u0026#39; Discrete logarithm calculator https://www.alpertron.com.ar/DILOG.HTM Base: g = 2 Power: B2 Modulus: fake_p \u0026#39;\u0026#39;\u0026#39; b = discrete_log(fake_p, B2, g) shared_secret = pow(A, b, p) print(decrypt_flag(shared_secret, iv, encrypted_flag)) ","description":"MTC-CTF is an exciting and challenging CTF competition brought to you by the Military Technical College (MTC) and the Egyptian Computer Emergency Readiness Team (EG|CERT).","id":0,"section":"ctfs","tags":["writeUps","Crypto"],"title":"ICMTC Crypto","uri":"https://s00ra.github.io/ctfs/icmtc/"},{"content":"Download link S01den\u0026rsquo;s cube Intro Welcome to my blog! Today, we will be diving into the world of solving a Rubik's cube, as represented by the crackme. As a huge fan of solving Rubik's cube, I was immediately drawn to this particular crackme challenge. I own a 3x3 Rubik's cube and have even been able to solve it in under 50 seconds ðŸ˜Š\nBefore diving into the reverse engineering process, let's first take a look at the file we will be working with. If we try to run the file and enter any input, we will immediately be presented with the message [!] Bad flag! This is to be expected\nCloser look It's time to take a closer look, so let's launch IDA and open our target file, and see what secrets we can uncover!\rOne of the first things we can do in IDA is to open the Strings view, which will show us all the hard-coded strings that are used in the program. By doing this, we can quickly locate the message [!] Bad flag!, which we encountered when we first ran the program. This is a good starting point, so letâ€™s jump to it.\rNow that we have located the [!] Bad flag! message in the program, let's move on to the main function to begin our analysis. The first thing we notice is that the program takes our input, which must be less than or equal to 99 characters, and then proceeds to loop through each character of the input. This is where the program checks if the input characters match any of the characters BDFLRUbdflru. The program then performs specific operations on a set of bytes defined in the program based on the input character.\rwhich are the basic moves of a Rubik's cube. As a Rubik's cube player, you already know that these symbols represent the Up, Down, Right, Left, Front, and Back moves of a Rubik's cube. Additionally, small symbols represent the vice versa.\rThere are 24 unique values. This tells us that this crackme is related to a 2x2 Rubik's cube. This is because a 2x2 Rubik's cube has 24 total cubes or stickers in total, which means each face has 4 stickers. This is consistent with the 24 unique values we found in the program's code.\rEach value is assigned to a different value. Upon further examination, we find that there are only 6 unique values [0x6f, 0x62, 0x76, 0x6a, 0x42, 0x72], which are related to the 4 colors in a 2x2 Rubik's cube (red, orange, blue, green, white, yellow).\rIt becomes clear that the program is checking the input against a scrambled 2x2 Rubik's cube. This means that we need to find the correct sequence of moves that will solve the scrambled cube. Solution To solve the crackme, we first need to understand the position of the bytes in the program and how they relate to the physical 2x2 Rubik's cube. We can also assign color to each value like cube = {0x6f: â€˜orangeâ€™, 0x72: â€˜redâ€™, 0x6a: â€˜greenâ€™, 0x42: â€˜whiteâ€™, 0x76: â€˜yellowâ€™, 0x62: â€˜blueâ€™}. (OR YOU CAN REPLACE WHITE TO YELLOW \u0026 GREEN TO BLUE \u0026 RED TO ORANGE)\nIn order to understand the physical location of the bytes, we can take advantage of the symbols represented in the switch case statements in the program. These symbols likely correspond to the basic moves of the Rubik's cube, such as Up, Down, Right, Left, Front, and Back. By analyzing the program's switch case statements, we can determine how the bytes are moved and manipulated in relation to the cube.\nBYTE_NUM\rVALUE\rCOLOR\rbyte_4049\r0x6F\rorange\rbyte_404A\r0x62\rblue\rbyte_404B\r0x76\ryellow\rbyte_404C\r0x62\rblue\rbyte_404D\r0x62\rblue\rbyte_404E\r0x6A\rgreen\rbyte_404F\r0x42\rwhite\rbyte_4050\r0x72\rred\rbyte_4051\r0x6F\rorange\rbyte_4052\r0x72\rred\rbyte_4053\r0x76\ryellow\rbyte_4054\r0x6A\rgreen\rbyte_4055\r0x42\rwhite\rbyte_4056\r0x76\ryellow\rbyte_4057\r0x72\rred\rbyte_4058\r0x6A\rgreen\rbyte_4059\r0x42\rwhite\rbyte_405A\r0x72\rred\rbyte_405B\r0x76\ryellow\rbyte_405C\r0x6A\rgreen\rbyte_405D\r0x42\rwhite\rbyte_405E\r0x6F\rorange\rbyte_405F\r0x62\rblue\rEx1\rEx2\rConclusion\rEx1 For example, when the case is 'L', we can notice that the program is swapping several bytes in the array which indicates that the left face of the cube is being rotated.\nEx2 For example, when the case is 'R', we can notice that the program is swapping several bytes in the array which indicates that the right face of the cube is being rotated.\nConclusion As you continue analyzing the switch cases and the byte movements, you will be able to map all the byte positions in the program to the physical positions of the stickers on the cube. This will give you a clear image of the cube's state and the moves required to solve it.\nOnce we have determined the positions of the bytes in relation to the physical 2x2 Rubik's cube, you can use online tools like cube solver Great, now that you have found the correct keys using the website, we can test your program by entering the keys as the input.\nBy inputting the correct keys, the program should verify the input and confirm that it is correct.\n","description":"Find a correct flag!","id":1,"section":"crackmes","tags":["crackmes","Unix/linux","REV"],"title":"S01den's cube","uri":"https://s00ra.github.io/crackmes/s01dens-cube/"},{"content":"About-Me Education Projects \u0026hellip;\u0026hellip; ","description":"about me","id":2,"section":"","tags":null,"title":"$whoami","uri":"https://s00ra.github.io/about/"}]