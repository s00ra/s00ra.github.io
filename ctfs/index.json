[{"content":"Twilight We encountered an image that contained some unkown characters. To analyze the cipher, I utilized the Symbols Cipher List on the dcode.fr website. It was determined that the cipher was the Hylian Language.\nDecrypting the cipher yielded the following text: REVWALJHEHIDDWNPLAINSWCRWJMESSADE. By making slight adjustments to the text,\n1 2 print(\u0026#34;REVWALJHEHIDDWNPLAINSWCRWJMESSADE\u0026#34;.replace(\u0026#34;W\u0026#34;, \u0026#34;E\u0026#34;).replace(\u0026#34;J\u0026#34;, \u0026#34;T\u0026#34;)) # and replace the last D in MESSADE with G Flag: EGCERT{REVEALTHEHIDDENPLAINSECRETMESSAGE} Simple Cipher Challenge 1 2 3 4 5 6 7 8 9 10 11 import os FLAG = open(\u0026#34;flag.txt\u0026#34;, \u0026#34;rb\u0026#34;).read() KEY = os.urandom(FLAG.index(b\u0026#34;{\u0026#34;)+1) def xor(plain): enc = b\u0026#34;\u0026#34; for i, c in enumerate(plain): enc += int.to_bytes(c ^ KEY[i % len(KEY)]) return enc.hex() print(xor(FLAG)) # out: 61bade96f3f7f36d90c29b92d1bb7b8aa9ba9692e61da2c9e3fefbb876dce0 Solution The challenge uses XOR encryption alogrithm and a 7-byte key length. It loop through the plaintext and encrypting the first 7 bytes, then repeating the key from the beginning.\nXOR is commutative means that aâŠ•b = bâŠ•a. XOR is associative means that aâŠ•(bâŠ•c) = (aâŠ•b)âŠ•c = (aâŠ•c)âŠ•b. If the plaintext was this_is_test and the key is key so the operation would be like this_is_test âŠ• keykeykeykey The key length matching the length of the flag format, which is EGCERT{. Therefore, we can XOR the first 7 characters of the cipher with the flag format to obtain the key.\n1 2 3 4 5 from pwn import xor out = bytes.fromhex(\u0026#34;61bade96f3f7f36d90c29b92d1bb7b8aa9ba9692e61da2c9e3fefbb876dce0\u0026#34;) known = b\u0026#34;EGCERT{\u0026#34; key = xor(out[:7], known) print(xor(out, key)) Flag: EGCERT{Im_H3r3_w4i71n9_T0_X0R!} Easy Encryption Challenge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from gmpy2 import next_prime from Crypto.Util.number import getPrime,bytes_to_long from random import randint import os from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/start/\u0026#39;) def decrypt(): flag = os.environ.get(\u0026#34;CTF_FLAG\u0026#34;, \u0026#34;EGCTF{FAKE_FLAAAAAAAAAAAAG}\u0026#34;) m1 = bytes_to_long(flag[:len(flag)//2]) m2 = bytes_to_long(flag[len(flag)//2:]) e = 0x10001 z = getPrime(512) p1 = getPrime(512) q1 = next_prime(p1) n1 = p1*q1 p2 = next_prime(q1) q2 = next_prime(p2) n2 = p2*q2 n3 = n1 * n2 n4 = q1 * getPrime(1024) c1 = (z * pow(m1,e,n3)) % n3 c2 = (m1*randint(1000,30000) * pow(m2,e,n4)) % n4 return {\u0026#39;n1\u0026#39;:int(n3) , \u0026#39;n2\u0026#39;:int(n4), \u0026#39;c1\u0026#39;:int(c1), \u0026#39;c2\u0026#39;:int(c2), \u0026#39;z\u0026#39;:int(z), \u0026#39;e\u0026#39;:int(e)} @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;Hi!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run() Solution It took me too much time, nearly 1H, until i reialized that he sent n3, n4 instead of n1, n2 ðŸ˜‚ðŸ˜‚.\nLet\u0026rsquo;s see, we have two equations\nc1 = (z * pow(m1, e, n3)) % n3\rc2 = (m1 * randint(1000,30000) * pow(m2, e, n4)) % n4\rlet\u0026rsquo;s find a starting point, if look at app.py we will notice that\nn3 = n1 * n2 = = p1 * q1 * p2 * q2\rn4 = q1 * RandomPrime\rS0o0, n3 and n4 have a common factor which is q1. We can use Common Prime Attack to retrieve factors of the moduli.\nIf N1 and N2 have a common factor that is mean GCD(N1, N2) != 1 We can calculate P as the following p = GCD(N1, N2), q1 = N1 // p, and q2 = N2 // p 1 2 3 4 5 6 7 8 9 10 import requests import json vals = json.loads(requests.get(\u0026#34;http://209.38.200.9:7715/start/\u0026#34;).text) n3, n4, c1, c2, z, e = vals[\u0026#39;n1\u0026#39;], vals[\u0026#39;n2\u0026#39;], vals[\u0026#39;c1\u0026#39;], vals[\u0026#39;c2\u0026#39;], vals[\u0026#39;z\u0026#39;], vals[\u0026#39;e\u0026#39;] n1 = GCD(n3, n4) n2 = n3 // n1 n4_rand = n4 // n1 # print(n1 * n2 == n3) # print(n4_rand * n1 == n4, isPrime(n4_rand), isPrime(n1)) Now we have n3 and n4 factors if we can get pow(m1, e, n3) and pow(m2, e, n4) then it will be easy to solve ðŸ™‚. Wait actuall we can !\nWe can retrieve pow(m1, e, n3) easily using Modular Division\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m # pow_m1_e_n3 = (c1 * inverse(z, n3)) % n3 pow_m1_e_n3 = modDivide(c1, z, n3) phi = (n1 - 1) * (n2 - 1) d = inverse(e, phi) m1 = pow(pow_m1_e_n3, d, n1) # EGCERT{16500bc003f74b4ba6ef96 Now doing the same with pow(m2,e,n4), but we just need to brute force the RandomNumber randint(1000,30000)\n1 2 3 4 5 6 7 8 9 10 11 12 13 # randint(1000,30000) * pow(m2,e,n4) rand_mul_pow_m2_e_n4 = modDivide(c2, m1, n4) for i in range(1000, 30000+1, 1): pow_m2_e_n4 = modDivide(rand_mul_pow_m2_e_n4, i, n4) phi = (n4_rand - 1) * (n1 - 1) d = inverse(e, phi) m2 = pow(pow_m2_e_n4, d, n4) if len(long_to_bytes(m2)) \u0026lt; 50: print(long_to_bytes(m2)) exit() Full code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import requests import json from Crypto.Util.number import GCD, inverse, long_to_bytes, isPrime # from sage.all import * def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m \u0026#39;\u0026#39;\u0026#39; c1 = (z * pow(m1,e,n3)) % n3 c2 = (m1 * randint(1000,30000) * pow(m2,e,n4)) % n4 \u0026#39;\u0026#39;\u0026#39; vals = json.loads(requests.get(\u0026#34;http://209.38.200.9:7715/start/\u0026#34;).text) n3, n4, c1, c2, z, e = vals[\u0026#39;n1\u0026#39;], vals[\u0026#39;n2\u0026#39;], vals[\u0026#39;c1\u0026#39;], vals[\u0026#39;c2\u0026#39;], vals[\u0026#39;z\u0026#39;], vals[\u0026#39;e\u0026#39;] n1 = GCD(n3, n4) n2 = n3 // n1 n4_rand = n4 // n1 # print(n1 * n2 == n3) # print(n4_rand * n1 == n4, isPrime(n4_rand), isPrime(n1)) # pow_m1_e_n3 = (c1 * inverse(z, n3)) % n3 pow_m1_e_n3 = modDivide(c1, z, n3) phi = (n1 - 1) * (n2 - 1) d = inverse(e, phi) # EGCERT{16500bc003f74b4ba6ef96 m1 = pow(pow_m1_e_n3, d, n1) # randint(1000,30000) * pow(m2,e,n4) rand_mul_pow_m2_e_n4 = modDivide(c2, m1, n4) for i in range(1000, 30000+1, 1): pow_m2_e_n4 = modDivide(rand_mul_pow_m2_e_n4, i, n4) phi = (n4_rand - 1) * (n1 - 1) d = inverse(e, phi) m2 = pow(pow_m2_e_n4, d, n4) if len(long_to_bytes(m2)) \u0026lt; 100: print(long_to_bytes(m2)) exit() print(\u0026#34;Failed\u0026#34;) Bad Mode Challenge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from flask import Flask import os from Crypto.Util.Padding import pad from Crypto.Cipher import AES import codecs KEY = os.urandom(16) app = Flask(__name__) @app.route(\u0026#39;/decrypt/\u0026lt;ciphertext\u0026gt;/\u0026#39;) def decrypt(ciphertext): ciphertext_bytes = codecs.decode(ciphertext, \u0026#34;hex\u0026#34;) decrypted = AES.new(KEY, AES.MODE_CBC, KEY).decrypt(ciphertext_bytes) return codecs.encode(decrypted, \u0026#34;hex\u0026#34;).decode() @app.route(\u0026#39;/encrypt/\u0026lt;plaintext\u0026gt;/\u0026#39;) def encrypt(plaintext): plaintext_bytes = codecs.decode(plaintext, \u0026#34;hex\u0026#34;) encrypted = AES.new(KEY, AES.MODE_CBC, KEY).encrypt(plaintext_bytes) return codecs.encode(encrypted, \u0026#34;hex\u0026#34;).decode() @app.route(\u0026#39;/check_key/\u0026lt;user_key\u0026gt;/\u0026#39;) def check_key(user_key): FLAG = os.environ.get(\u0026#34;FLAG\u0026#34;) FLAG = pad(FLAG.encode(), 16) user_key_bytes = codecs.decode(user_key, \u0026#34;hex\u0026#34;) return codecs.encode(FLAG, \u0026#34;hex\u0026#34;).decode() if user_key_bytes == KEY else \u0026#34;Try Again !!\u0026#34; @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;Hi!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run() Solution Using the key as an IV is insecure; an attacker that can modify ciphertext in flight can get the receiver to decrypt a value that will reveal the key. [Here you can find a better explanation]\nencrypt the message that is at least 3 blocks long AES-CBC(P_1, P_2, P_3) -\u0026gt; C_1, C_2, C_3 Modify the message (you are now the attacker) C_1, C_2, C_3 -\u0026gt; C_1, 0, C_1 Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found. As the attacker, recovering the plaintext from the error, extract the key: P\u0026rsquo;_1 XOR P\u0026rsquo;_3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import requests import json from Crypto.Util.number import bytes_to_long url = \u0026#34;http://209.38.200.9:7710/\u0026#34; def decrypt(cipher): new_url = url + \u0026#34;decrypt\u0026#34; + \u0026#34;/\u0026#34; + cipher + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text def encrypt(plaintext): new_url = url + \u0026#34;encrypt\u0026#34; + \u0026#34;/\u0026#34; + plaintext + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text def check_key(key): new_url = url + \u0026#34;check_key\u0026#34; + \u0026#34;/\u0026#34; + key + \u0026#34;/\u0026#34; res = requests.get(new_url) return res.text # any plaintext plaintext = (b\u0026#39;a\u0026#39;*(16*3)).hex() # decrypt the plaintext # we get c1 -\u0026gt; c2 -\u0026gt; c3 response_cipher = encrypt(plaintext) response_cipher = json.loads(response_cipher) cipher = response_cipher[\u0026#39;ciphertext\u0026#39;] # Modify the message # C_1, C_2, C_3 -\u0026gt; C_1, 0, C_1 fake_cipher = cipher[:32] + \u0026#39;0\u0026#39;*32 + cipher[:32] # we get the fake plaintext response_plain = decrypt(fake_cipher) response_plain = json.loads(response_plain) fake_plain = bytes.fromhex( response_plain[\u0026#39;error\u0026#39;][19:] ) # the length of fake_plain is 48 # As the attacker, recovering the plaintext from the error, extract the key: # P\u0026#39;_1 XOR P\u0026#39;_2 iv = [0]*16 for i in range(len(iv)): iv[i] = fake_plain[i] ^ fake_plain[32+i] key = bytes(iv).hex() response_flag = check_key(key) response_flag = json.loads(response_flag) Sign Gate RSA has a homomorphic property. First, we need to understand what homomorphic means and how we can utilize this property to sign our message\nWhat is homomorphic encryption It\u0026rsquo;s property that allows performing certain operations on encrypted data, resulting in equivalent operations on the plaintext when decrypted.\nMultiplicative homomorphism specifically means that given the encrypted values of two plaintexts, it is possible to compute the encryption of their product without decrypting them.\nRSA, does not possess full multiplicative homomorphism. However, it does have a limited form of homomorphic property with respect to multiplication.\nHow we can utilize this The rules of exponents say that (a)n * (b)n = (ab)n. This means that multiplying two ciphertexts encrypted with the same key is equivalent to raising the product of the plaintexts to the power of the secret key. Therefore, RSA is multiplicatively homomorphic. [1]\nc1c2 mod N = m1dm2d mod N = (m1m2)d mod N\r1 2 3 4 5 6 7 8 9 10 11 from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, inverse, long_to_bytes key = RSA.generate(2048) msg1 = bytes_to_long(b\u0026#34;this_is_msg_1\u0026#34;); msg2 = bytes_to_long(b\u0026#34;test\u0026#34;) enc1 = pow(msg1, key.e, key.n); enc2 = pow(msg2, key.e, key.n) # first multiplying two ciphers cipher_product = (enc1 * enc2) % key.n # encrypt the cipher_product with the same key == product of two msgs print(pow(cipher_product, key.d, key.n) == msg1 * msg2) Think\rSolution\rThink Now Think about it, how can we sign our msg ðŸ¤”?\rSolution We need to get a msg_enc = pow(b'Crypt0N19h7'), d, n) but the server will not accept our msg s0o0oo, if we for example sign msg+b'\\x00' which is bytes_to_long(msg)*256 we will have msg_mul_256_enc = pow(bytes_to_long(b'Crypt0N19h7\\x00'), e, n) and sign (256), num_256_enc = pow((256), e, n)\nmsg_mul_256_enc = pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\\x00\u0026rsquo;), e, n) = pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\u0026rsquo;) * 256, e, n)\nnum_256_enc = pow((256), e, n)\nWe can get pow(bytes_to_long(b\u0026rsquo;Crypt0N19h7\u0026rsquo;), e, n) using modular multiplicative inverse\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * import ast from Crypto.Util.number import bytes_to_long, inverse def sign_msg(n): r.sendline(b\u0026#34;1\u0026#34;) r.recvuntil(b\u0026#39;Enter message to sign: \u0026#39;) r.sendline(str(n).encode()) val = int(r.recvuntil(b\u0026#39;=\u0026gt; \u0026#39;)[:-4].decode()) return val def check(n): r.sendline(b\u0026#34;2\u0026#34;) r.recvuntil(b\u0026#39;Enter signature to verify: \u0026#39;) r.sendline(str(n).encode()) print(r.recvline()) print(r.recvline()) def modDivide(a,b,m): a %= m inv = inverse(b,m) if(inv == -1): return -1 else: return (inv*a) % m r = remote(\u0026#39;209.38.200.9\u0026#39;, 7725) x = r.recvuntil(b\u0026#39;=\u0026gt; \u0026#39;) pub_key = ast.literal_eval(x[x.find(b\u0026#34;(\u0026#34;):x.find(b\u0026#34;)\u0026#34;)+1].decode()) n, e = pub_key[0], pub_key[1] msg = bytes_to_long(b\u0026#34;Crypt0N19h7\u0026#34;) msg *= 256 # msg = b\u0026#39;Crypt0N19h7\\x00\u0026#39; msg_mul_256 = sign_msg(msg) sign_256 = sign_msg(256) msg_sign = modDivide(msg_mul_256, sign_256, n) check(msg_sign) Parameter Injection We are allowed to send the parameters A, g, and p to Bob. This enables us to send a smooth number p, which allows us to apply the Pohlig-Hellman Attack.\nWhat is smooth number\rWhat is Pohlig-Hellman Attack\rWhat is smooth number Smooth number is a number which can be written from small prime factors. Smooth number must be a prime so that we can use Pohlig-Hellman Attack, the use of a smooth prime is a crucial step in efficiently computing the discrete logarithm.\rWhat is Pohlig-Hellman Attack In the Pohlig-Hellman Attack, we aim to compute the discrete logarithm of a given value. Let\u0026rsquo;s say we have a generator g, a prime modulus p, and a public value A such that A â‰¡ g^a (mod p) for some unknown private exponent a.\nIt factoring the smooth prime p-1 into its prime factors. Let\u0026rsquo;s denote these prime factors as p_1, p_2, ..., p_k. For each prime factor p_i, we compute a partial discrete logarithm x_i using the Chinese Remainder Theorem (CRT) method.\nBy applying the CRT to the partial discrete logarithms, we can reconstruct the full discrete logarithm a modulo p-1. Once we have a, we can compute the shared secret key.\nThe use of a smooth prime* allows us to efficiently compute the partial discrete logarithms and apply the CRT to reconstruct the full discrete logarithm.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrime, getPrime from sympy.ntheory.residue_ntheory import discrete_log from Crypto.Util.Padding import pad, unpad from Crypto.Cipher import AES import hashlib import json from pwn import * def repeat(n): x = 1 for i in range(n): x *= getPrime(32) return x*2+1 def create_weak_prime(n): while True: x = repeat(n) if isPrime(x): print(x) break def decrypt_flag(shared_secret, iv, ciphertext): key = hashlib.sha1(str(shared_secret).encode()).hexdigest()[:16].encode() cipher = AES.new(key, AES.MODE_CBC, bytes.fromhex(iv)) decrypted_data = cipher.decrypt(bytes.fromhex(ciphertext)) plaintext = unpad(decrypted_data, 16).decode() return plaintext conn = remote(\u0026#39;209.38.200.9\u0026#39;, 7720) conn.recvuntil(b\u0026#34;Intercepted from Alice: \u0026#34;) alice = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) p = alice[\u0026#39;p\u0026#39;] g = alice[\u0026#39;g\u0026#39;] A = alice[\u0026#39;A\u0026#39;] conn.recvuntil(b\u0026#34;Intercepted from Bob: \u0026#34;) bob = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) B = bob[\u0026#39;B\u0026#39;] conn.recvuntil(b\u0026#34;Intercepted from Alice: \u0026#34;) alice_iv = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) iv = alice_iv[\u0026#39;iv\u0026#39;] encrypted_flag = alice_iv[\u0026#39;encrypted\u0026#39;] fake_p = create_weak_prime(64) val = json.dumps({\u0026#34;p\u0026#34;:fake_p, \u0026#34;g\u0026#34;:g, \u0026#34;A\u0026#34;:A}) conn.recvuntil(b\u0026#34;Bob connects to you, send him some parameters:\\n\u0026#34;) conn.sendline(val.encode()) conn.recvuntil(b\u0026#34;Bob says to you: \u0026#34;) bob2 = json.loads(conn.recvuntil(b\u0026#34;}\u0026#34;)) B2 = bob2[\u0026#39;B\u0026#39;] \u0026#39;\u0026#39;\u0026#39; Discrete logarithm calculator https://www.alpertron.com.ar/DILOG.HTM Base: g = 2 Power: B2 Modulus: fake_p \u0026#39;\u0026#39;\u0026#39; b = discrete_log(fake_p, B2, g) shared_secret = pow(A, b, p) print(decrypt_flag(shared_secret, iv, encrypted_flag)) ","description":"MTC-CTF is an exciting and challenging CTF competition brought to you by the Military Technical College (MTC) and the Egyptian Computer Emergency Readiness Team (EG|CERT).","id":0,"section":"ctfs","tags":["writeUps","Crypto"],"title":"ICMTC Crypto","uri":"https://s00ra.github.io/ctfs/icmtccrypto/"},{"content":"Oriris Let\u0026rsquo;s begin by loading the challenge onto IDA. The program prompts the user for input and passes it to the check_flag() function. If the return value is 1, it displays the message Correct Flag :). Otherwise, it will print Wrong Flag :( message.\nUpon examining the check_flag() function, we can observe multiple conditional checks. These conditions can be translated into constraints in the Z3 solver to obtain the flag. Notably, the largest index being checked is user_input[41], indicating that the flag length is 42.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from z3 import * rol = lambda val, r_bits, max_bits=8: \\ (val \u0026lt;\u0026lt; r_bits%max_bits) \u0026amp; (2**max_bits-1) | \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; (max_bits-(r_bits%max_bits))) # Rotate right. Set max_bits to 8. ror = lambda val, r_bits, max_bits=8: \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; r_bits%max_bits) | \\ (val \u0026lt;\u0026lt; (max_bits-(r_bits%max_bits)) \u0026amp; (2**max_bits-1)) solver = z3.Solver() FLAG_LEN = 42 flag = [BitVec(\u0026#34;c_%i\u0026#34; % i ,32) for i in range(FLAG_LEN)] # CHARACTERS MUST BE PRINTABLE for char in flag: solver.add(char \u0026gt;= 0 , char \u0026lt;= 127) solver.add(ror(rol(flag[0], 48), 51) == 0xA8) solver.add(rol(rol(flag[1], 16), 15) == 0xA3) solver.add((rol(flag[2], 68) ^ 0x3A) == 14) solver.add(ror(flag[3] ^ 0x43, 47) == 12) solver.add(ror(flag[4] ^ 0xC, 47) == 0xBC) solver.add((rol(flag[5], 20) ^ 0x11) == 84) solver.add(rol(flag[6] ^ 0x12, 42) == 0xA5) solver.add(rol(ror(flag[7], 56), 68) == 83) solver.add(ror(flag[8] ^ 0x38, 19) == 97) solver.add((ror(flag[9], 67) ^ 0x1F) == 121) solver.add(ror(ror(flag[10], 38), 60) == 0xD7) solver.add(rol(ror(flag[11], 51), 51) == 49) solver.add(rol(rol(flag[12], 28), 21) == 0xCC) solver.add(ror(flag[13] ^ 0x3A, 42) == 89) solver.add(ror(ror(flag[14], 16), 42) == 94) solver.add(ror(rol(flag[15], 48), 24) == 48) solver.add((ror(flag[16], 39) ^ 0x20) == 0xCA) solver.add(ror(ror(flag[17], 35), 43) == 125) solver.add(rol(ror(flag[18], 19), 62) == 35) solver.add(rol(ror(flag[19], 58), 12) == 0xCC) solver.add((rol(flag[20], 13) ^ 0x13) == 0xB5) solver.add(ror(flag[21] ^ 0x27, 21) == 0xA0) solver.add((flag[22] ^ 0x33) == 97) solver.add((ror(flag[23], 38) ^ 0x19) == 0xC0) solver.add(rol(flag[24] ^ 0x1B, 34) == 0xA0) solver.add(ror(ror(flag[25], 36), 44) == 95) solver.add((flag[26] ^ 0x79) == 14) solver.add(rol(ror(flag[27], 20), 10) == 26) solver.add((rol(flag[28], 69) ^ 0x3A) == 0xBC) solver.add((rol(flag[29], 18) ^ 0x3F) == 0xE3) solver.add(rol(flag[30] ^ 0x33, 46) == 27) solver.add(rol(rol(flag[31], 39), 44) == 27) solver.add((ror(flag[32], 33) ^ 0x19) == 1) solver.add(ror(ror(flag[33], 38), 60) == 91) solver.add((flag[34] ^ 0x3D) == 14) solver.add(ror(flag[35] ^ 0x3E, 19) == 97) solver.add(rol(ror(flag[36], 35), 24) == 0xEB) solver.add(ror(rol(flag[37], 49), 55) == 0xB9) solver.add(ror(ror(flag[38], 43), 11) == 0xCC) solver.add((flag[39] ^ 0x33) == 75) solver.add(flag[40] == 0x37) solver.add(ror(rol(flag[41], 12), 10) == 0xF5) if solver.check() == sat: model = solver.model() for char in range(len(flag)): flag[char] = model[flag[char]].as_long() print(\u0026#39;\u0026#39;.join([chr(x) for x in flag])) else: print(\u0026#34;no solution found\u0026#34;) Flag: EGCERT{533_1f_y0u_d353Rv3_wh47_c0m35_n3x7} Registry If we open the file sample.reg in any text editor, we can observe that\nthe script adds an entry in the RunOnce key of the current user\u0026rsquo;s registry. This entry contains a startup command that is executed once when the user logs in.\nThe command launches a hidden PowerShell window and performs a series of actions.\nFirst, the PowerShell command searches for a registry file (.reg) within the C:\\ drive and its subdirectories. It looks for a file with a size of 0x00026A83 bytes, which is the same size as our file sample.reg [Size: 158,339 bytes].\nOnce it finds a file matching the size criterion, it retrieves the full path of the file. Next, the script creates a temporary batch file named tmpreg.bat in the user\u0026rsquo;s temporary folder (%temp%). It then copies the selected registry file to the location of the temporary batch file. The content of the tmpreg.bat file is read as a byte array.\nThe script iterates over each byte in the array and performs an XOR operation with the value 0x77.\nAfter encryption, a path is generated for a new executable file within the user\u0026rsquo;s temporary folder.\nAlright, let\u0026rsquo;s XOR the contents of the sample.reg file with the key 0x77 to obtain the executable binary.\nDownload the XORed file from CyberChef and reformat it to obtain the binary file.\rLet\u0026rsquo;s load the binary into IDA and begin the analysis. Open the strings tab and, we come across three interesting strings egcert_%d, COMPUTERNAME, checkmate. Let\u0026rsquo;s jump to the function that contain egcert_%d\nThis particular function appears to be responsible for storing the FLAG if a specific conditions happend. The Destination variable will holds the value that will be stored in the file. Initially, it concatenates the Source value, which is the word EGCERT{ with the Destination variable. Then, it enters a loop where we notice that the condition is always true. However, there is an if condition that checks if v1 [The counter] equals 8. If this condition is met, it stores the value of Destination in the file and exits.\nDuring debugging, I observed that the function sub_7FF684BABA20() stores the value egcert_0 when v1 is 0 into VarName variable and then attempts to retrieve the value of an environment variable with the same name using getenv(). If the variable with the name egcert_0 exists in the environment variable, the function compares it with qword_7FF684BB8040[0]. If they are equal, it increments v1 [The counter], add the value of qword_7FF684BB8040[0] to the Destination variable and adds an underscore \u0026lsquo;_\u0026rsquo; to Destination.\nFrom the above analysis, we can deduce that qword_7FF684BB8040 must be an array with 8 values, representing the flag. To explore this further, let\u0026rsquo;s examine the Xrefs for this function.\nAs mentioned earlier, a specific condition must be met to execute the get_flag() function. This condition requires that our COMPUTERNAME variable matches the string checkmate for the get_flag() function to be executed.\nWe can patch the code to execute get_flag() function. Let\u0026rsquo;s examine the Xrefs of this function and set a breakpoint on it.\nSOLUTION\n1 2 var = [\u0026#39;iesr3v3r\u0026#39;, \u0026#39;gn\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;g3r\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;s3l1f\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;htiw\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;d3dd3bm3\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;3lbatuc3xe\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;3d0c\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;3db6bcc9\u0026#39;] print(\u0026#34;EGCERT{\u0026#34; + \u0026#34;\u0026#34;.join(var[::-1])[::-1] + \u0026#34;}\u0026#34;, end=\u0026#39;\u0026#39;) Flag: EGCERT{r3v3rseing_r3g_f1l3s_with_3mb3dd3d_ex3cutabl3_c0d3_9ccb6bd3} CppFusion 1 2 ahmed@DESKTOP-FCBJDP8:~$ CppFusion.exe no Our main focus is to determine the source of the no message. To begin our analysis, let\u0026rsquo;s load the program into IDA. If we look at strings we won\u0026rsquo;t find anything. Examining the main() we will find an interesting part, let\u0026rsquo;s check the result value and what is function sub_439A94()\nsub_439A94\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 int __usercall sub_439A94@\u0026lt;eax\u0026gt;(int a1@\u0026lt;esi\u0026gt;, int a2, int a3) { _DWORD *v3; // eax _DWORD *v4; // eax _DWORD *v5; // eax _DWORD *v6; // eax int v7; // ecx _DWORD *v8; // eax _DWORD *v9; // eax int v10; // eax const char *v11; // eax char *Buffer; // [esp+0h] [ebp-98h] BYREF int v14; // [esp+14h] [ebp-84h] int v15; // [esp+18h] [ebp-80h] char v16[4]; // [esp+1Ch] [ebp-7Ch] BYREF int v17; // [esp+20h] [ebp-78h] int (__cdecl *v18)(int, int, int, int, int, int); // [esp+34h] [ebp-64h] int *v19; // [esp+38h] [ebp-60h] int *v20; // [esp+3Ch] [ebp-5Ch] void *v21; // [esp+40h] [ebp-58h] char **p_Buffer; // [esp+44h] [ebp-54h] char v23; // [esp+57h] [ebp-41h] BYREF int v24; // [esp+58h] [ebp-40h] BYREF int v25; // [esp+5Ch] [ebp-3Ch] BYREF int v26[3]; // [esp+60h] [ebp-38h] BYREF char v27[8]; // [esp+6Ch] [ebp-2Ch] BYREF int v28; // [esp+74h] [ebp-24h] BYREF int v29; // [esp+78h] [ebp-20h] BYREF int v30; // [esp+7Ch] [ebp-1Ch] int *v31; // [esp+88h] [ebp-10h] int savedregs; // [esp+98h] [ebp+0h] BYREF v31 = \u0026amp;a2; v15 = a2; v18 = sub_439190; v14 = a3; v19 = dword_43A7E8; v20 = \u0026amp;savedregs; v21 = \u0026amp;loc_439D2D; p_Buffer = \u0026amp;Buffer; sub_41A0B0(v16); sub_418630(); v24 = 0; v23 = 0; v25 = *(_DWORD *)(v14 + 4); if ( v15 != 2 ) goto LABEL_3; v26[0] = 3; v23 = 1; memset(\u0026amp;v26[1], 0, 8u); v28 = 0; v29 = 0; memset(v27, 0, sizeof(v27)); v17 = 6; v3 = (_DWORD *)sub_438520(8u); *v3 = \u0026amp;off_441AB4; v3[1] = \u0026amp;v24; sub_433F7C(v3); v17 = 1; v4 = (_DWORD *)sub_438520(0x14u); *v4 = \u0026amp;off_442E14; v4[1] = \u0026amp;v25; v4[3] = v26; v4[2] = \u0026amp;v24; v4[4] = \u0026amp;v23; sub_433F98(v4); v17 = 1; sub_42C300(\u0026amp;v28, a1); sub_43232C(\u0026amp;v29); sub_432338(\u0026amp;v28); sub_433D30(\u0026amp;v27[4]); v28 = 0; memset(v27, 0, sizeof(v27)); v29 = 0; v30 = 0; v17 = 7; v5 = (_DWORD *)sub_438520(8u); *v5 = \u0026amp;off_442E28; v5[1] = \u0026amp;v24; sub_433F7C(v5); v17 = 2; v6 = (_DWORD *)sub_438520(0xCu); *v6 = \u0026amp;off_442E3C; v6[1] = \u0026amp;v23; v6[2] = v26; sub_433F98(v6); v17 = 2; sub_42C2B0(\u0026amp;v28, v7); sub_42C2DC(\u0026amp;v28); sub_433D30(\u0026amp;v27[4]); v28 = 0; memset(v27, 0, sizeof(v27)); v29 = 0; v30 = 0; v17 = 8; v8 = (_DWORD *)sub_438520(0xCu); *v8 = \u0026amp;off_442E50; v8[1] = \u0026amp;v25; v8[2] = \u0026amp;v24; sub_433F7C(v8); v17 = 3; v9 = (_DWORD *)sub_438520(0xCu); *v9 = \u0026amp;off_442E64; v9[1] = \u0026amp;v23; v9[2] = v26; v10 = sub_433F98(v9); v17 = 3; sub_42C2B0(\u0026amp;v28, v10); sub_42C2DC(\u0026amp;v28); sub_433D30(\u0026amp;v27[4]); sub_433D30(\u0026amp;v26[2]); v11 = \u0026#34;yes\u0026#34;; if ( !v23 ) LABEL_3: v11 = \u0026#34;no\u0026#34;; v17 = -1; puts(v11); v15 = 0; sub_41A380(v16); return v15; } To understand how the program determines whether to display the yes or no message, I began debugging this function. I stepped through the code until I reached the instruction where it compares v15 with 2. If the comparison is false, it print out the no message. In this case, the condition was false cause v15 equal to 1. To proceed, I patched the zero flag (ZF) and continued execution.\nAs we continued our debugging process, we got an error message. 282244: The instruction at 0x282244 referenced memory at 0x0. The memory could not be read -\u0026gt; 00000000 (exc.code c0000005, tid 8932) and moved to this function\nIt appears that the value we patched, v15, is responsible for checking whether a parameter has been passed to the program. Let\u0026rsquo;s attach a parameter and set a breakpoint on the function where we encountered the memory error. This particular function seems to access our input for performing the necessary checks.\nBy debugging the program, we can locate our input. I added a hardware breakpoint on the input and continued. It compares the first character of our input with the first character of the flag, which is E\n\u0026nbsp;\u0026nbsp;\rHere, we can see two images representing different functions, each cmp byte ptr [edx+eax] \u0026lt;single char of the flag\u0026gt;. These functions are located at different offsets within the binary, but the fixed difference between them is 46. We can write a Python script to extract each character of the flag.\nImg1\rImg2\r1 2 3 4 5 6 7 8 9 10 f = open(\u0026#34;CppFusion.exe\u0026#34;, \u0026#34;rb\u0026#34;).read() base_addr = 0x1622 flag = \u0026#34;flag: \u0026#34; while flag[-1] != \u0026#34;}\u0026#34;: flag += chr(f[base_addr+3]) base_addr -= 46 print(flag) Flag: EGCERT{r3v3rs3_3nG1n33r1nG_w1th_CPP_RTT1_15_4w3s0m3_c68bc217} B14ckB0X This challenge is protected with VMProtect. Therefore, I did not attempt to load it in IDA or even debug it ðŸ˜‚ðŸ˜‚, actually i tried to encrypt a very large file, suspend the process, and attach it to x64dbg, and use VMPImportFixer.exe but this method didn\u0026rsquo;t work. Instead, I focused on alternative approaches to analyze the binary.\nWe just stopped the execution somewhere; part of this program already ran.\rI attempted multiple encryption operations using various files.\nCase 1\rCase 2\rCase 3\rCase 4\rSummary\rCase 1 I utilized the following command to generate a file filled with null bytes\nfsutil.exe file createNew null_byte.jpg 200\rNext, let's encrypt this file and see the result\rB14ckB0X.exe null_byte.jpg\rwe will notice that those 24 bytes 0F 41 C3 91 BF 98 0F B0 76 41 1D 98 85 46 76 68 B4 91 83 4F 40 A2 0F C2 are repeated which mean that we are dealing with a stream cipher\nCase 2 Let\u0026rsquo;s try to repalce 00 with 01\nNext, let\u0026rsquo;s encrypt this file and see the result\nB14ckB0X.exe 01_byte.jpg\rSame case but with different bytes 61 3C 52 31 B5 4C 61 F9 07 3C 34 4C BE 6A 07 FF B3 31 94 89 24 01 61 96\nCase 3 Now let\u0026rsquo;s try a combination of 00 and 01\nNext, let\u0026rsquo;s encrypt this file and see the result\nB14ckB0X.exe 01_00_byte.jpg\rHere, the results become even more interesting. We will notice that the result of encrypting 01 bytes is the same as 01_byte_enc file 61 3C 52 31 B5 4C 61 F9 07 3C 34 4C BE 6A 07 FF B3 31 94 89 24 01 61 96 and 00 is the same as null_byte_enc file 0F 41 C3 91 BF 98 0F B0 76 41 1D 98 85 46 76 68 B4 91 83 4F 40 A2 0F C2\nCase 4 Let\u0026rsquo;s encrypt a single byte for example F4. The result will be\nNext, try 00 and F4. We will notice that 00 is the same as the first value in null_byte file which is 0F and F4 encryption result is 9B\nLol, it\u0026rsquo;s actually depend on the index of the byte, and it\u0026rsquo;s value so, if we want to get the same result of encrypting a single byte F4 we will do the following\nSummary To decrypt the encrypted file and retrieve the original values, we need to construct our encryption table containing all possible encryption mappings. By comparing this encryption table with the encrypted file, we can determine the original values that were encrypted.\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import os pt_tb = bytearray([i for i in range(256) for _ in range(24)]) with open(\u0026#34;pt_tb\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write( pt_tb ) os.system(\u0026#34;B14ckB0X.exe pt_tb\u0026#34;) enc_tb = bytearray(open(\u0026#34;pt_tb.joez\u0026#34;, \u0026#34;rb\u0026#34;).read()) enc_flag = bytearray(open(\u0026#34;flag.jpg.joez\u0026#34;, \u0026#34;rb\u0026#34;).read()) dec_flag = [] for i in range(0, len(enc_flag), 24): for j in range(len(enc_flag[i:i+24])): for k in range(0, len(enc_tb), 24): val = enc_tb[k:k+24][j] if val == enc_flag[i:i+24][j]: dec_flag.append(pt_tb[k:k+24][j]) break with open(\u0026#34;flag.jpg\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write( bytes(dec_flag) ) Nightmare [NOT DONE YET] This challenge utilizes Control-flow Flattening as an obfuscation technique. In this technique, a control_flow value (represented by rax in this challenge) determines which block of code to execute. The control_flow value is altered, and the program loops to execute the next block, repeating this process iteratively.\nAt first, the program checks whether the user has passed a parameter to it or not. It also verifies the length of the parameter to determine if it matches the expected flag length, which in this case, appears to be 48 characters. We will also noticed that the initial value of the control_flow variable is defined.\nLet\u0026rsquo;s begin the debugging process.\nEq1\rEq2\rThat\u0026#39;s Enough\rEq1 control_flow = 0x871B439D3AB58593 # initial value\ni ^= usr_input[31] where i equal to 0\nnext control_flow = 0xE77D09EC61DBFDFD\nIt hit the default case\ni *= 0x7BA\ncontrol_flow = 0x8555347719FF1A7A\ni *= 988\ncontrol_flow = 0xFEE1F097A9C92F4B\ni *= 2228\ncontrol_flow = 0xA4DF404AD1AAC8EE\ni += usr_input[11]\ncontrol_flow = 0xE2AF025EB8A28336\ni ^= usr_input[15]\ncontrol_flow = 0xD91C08E550BE5766\ni += usr_input[35]\ncontrol_flow = 0xE5825B9CD01F9C26\ni -= usr_input[27]\ncontrol_flow = 0xF6DE02EB40B1F592\nnow it check the i value\nOur mission here to get all the equations, then do some **Z3\nusr_input[31] * 0x7BA * 988 * 2228 + usr_input[11] ^ usr_input[15] + usr_input[35] - usr_input[27] == 0x696E8ED357\rcontrol_flow = 0xC5D5B57C1CBC8C6E\nThen he sit i = 0\nEq2 i *= 2532i64\ncontrol_flow = 0xCC01DD89959CC7DD\nAgain, it\u0026rsquo;s repeating itself with a different control_flow value\ncontrol_flow = 0xB55038A0BD1CC3E0\ni *= 123\ni ^= user_input[24]\ncontrol_flow = 0xDD4199AC325220C2\ni ^= user_input[28]\ncontrol_flow = 0xEBDB474AC55BB5B4\ni += user_input[16]\ncontrol_flow = 0xF58177BDE4872B30\ni *= 595i64;\ncontrol_flow = 0x939AC27453EE9EC9\ni -= user_input[36]\ncontrol_flow = 0xDC59BF762D22FA6C\ni *= 3379i64\ncontrol_flow = 0xEB048CB33E997319\nHere is the second equation\n0 ^ user_input[24] ^ user_input[28] + user_input[16] * 595 - user_input[36] * 3379 == 283139926\rcontrol_flow = 0x8635B1FB0AA13299\ri = 0\rThat\u0026rsquo;s Enough I had a question in my mind about how many equations I needed to obtain the flag. To find out, I examined the wrong condition. Surprisingly, there were nearly 32 equations ðŸ˜¯ðŸ˜¯ðŸ˜¯.\nAt this point, it became clear that we needed to start considering an automated approach to solve the challenge.\rI have already written a code that steps through the program, extracting each part of the equation until it retrieves the full set of equations. However, it encounters an issue at equation number 5 where the dumpulator executes jz to be true when zf = 0, and I\u0026rsquo;m uncertain why this occurs. I may consider exploring an alternative approach in the future. If anyone has another approach or solution, feel free to reach out to me on Discord 50r4. I would greatly appreciate it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 from dumpulator import Dumpulator from struct import pack import ida_lines import idaapi import idc import time dp = Dumpulator(\u0026#34;night.dmp\u0026#34;, quiet=True) ida_base = \u0026#34;0x7FF60E49\u0026#34; jumps = [\u0026#39;je\u0026#39;, \u0026#39;jz\u0026#39;, \u0026#39;jne\u0026#39;, \u0026#39;jnz\u0026#39;, \u0026#39;jl\u0026#39;, \u0026#39;jge\u0026#39;, \u0026#39;jle\u0026#39;, \u0026#39;jg\u0026#39;, \u0026#39;jo\u0026#39;, \u0026#39;jno\u0026#39;, \u0026#39;jc\u0026#39;, \u0026#39;jnc\u0026#39;, \u0026#39;jbe\u0026#39;, \u0026#39;ja\u0026#39;, \u0026#39;js\u0026#39;, \u0026#39;jns\u0026#39;, \u0026#39;jp\u0026#39;, \u0026#39;jnp\u0026#39;, \u0026#39;jmp\u0026#39;] get_last_4_value = lambda x: hex(x)[-4:] map_to_ida = lambda x: int(ida_base + get_last_4_value(x), 16) map_to_x_64 = lambda x: int(\u0026#34;0x00007FF6B1F5\u0026#34; + get_last_4_value(x), 16) get_assembly = lambda x: idc.GetDisasm(int(ida_base + get_last_4_value(x), 16)) # https://reverseengineering.stackexchange.com/questions/30252/idapython-how-to-get-decompiler-output-corresponding-to-the-indirect-call def find_parent_cinsn(cfunc, citem): if not citem.is_expr(): return citem cinsn = None class cvisitor(idaapi.ctree_visitor_t): def __init__(self): super().__init__(idaapi.CV_FAST | idaapi.CV_PARENTS) def visit_expr(self, expr) -\u0026gt; int: nonlocal cinsn if expr.obj_id == citem.obj_id: for parent in reversed(self.parents): if not parent.is_expr(): cinsn = parent break return 1 # Stop enumeration return 0 cvisitor().apply_to(cfunc.body, None) return cinsn def pseudo_for_ea(ea): cfunc = idaapi.decompile(ea) citem = cfunc.body.find_closest_addr(ea) citem = find_parent_cinsn(cfunc, citem) if citem: for item in cfunc.get_pseudocode(): if format(citem.index, \u0026#34;X\u0026#34;).zfill(16) in item.line.split()[0]: decomp = ida_lines.tag_remove(item.line) return decomp.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;;\u0026#34;, \u0026#34;\u0026#34;) def get_addr_of_loc(instr_code): loc_val = instr_code.split(\u0026#34; \u0026#34;)[-1] current_function = idaapi.get_func(here()) target_address = idaapi.get_name_ea(current_function.start_ea, loc_val) return target_address def is_jump_taken(instr_code, eflags): jumps_type = instr_code.split(\u0026#34; \u0026#34;)[0] eflags_dic = { \u0026#34;CF\u0026#34;: (eflags \u0026amp; 1), # Carry Flag \u0026#34;PF\u0026#34;: (eflags \u0026gt;\u0026gt; 2) \u0026amp; 1, # Parity Flag \u0026#34;AF\u0026#34;: (eflags \u0026gt;\u0026gt; 4) \u0026amp; 1, # Auxiliary Carry Flag \u0026#34;ZF\u0026#34;: (eflags \u0026gt;\u0026gt; 6) \u0026amp; 1, # Zero Flag \u0026#34;SF\u0026#34;: (eflags \u0026gt;\u0026gt; 7) \u0026amp; 1, # Sign Flag \u0026#34;TF\u0026#34;: (eflags \u0026gt;\u0026gt; 8) \u0026amp; 1, # Trap Flag \u0026#34;IF\u0026#34;: (eflags \u0026gt;\u0026gt; 9) \u0026amp; 1, # Interrupt Flag \u0026#34;DF\u0026#34;: (eflags \u0026gt;\u0026gt; 10) \u0026amp; 1, # Direction Flag \u0026#34;OF\u0026#34;: (eflags \u0026gt;\u0026gt; 11) \u0026amp; 1 # Overflow Flag } # http://unixwiz.net/techtips/x86-jumps.html if jumps_type == \u0026#34;ja\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 0 and eflags_dic[\u0026#34;ZF\u0026#34;] == 0 elif jumps_type == \u0026#34;jae\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 0 elif jumps_type == \u0026#34;jb\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 1 elif jumps_type == \u0026#34;jbe\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 1 or eflags_dic[\u0026#34;ZF\u0026#34;] == 1 elif jumps_type == \u0026#34;jc\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 1 elif jumps_type == \u0026#34;je\u0026#34; or jumps_type == \u0026#34;jz\u0026#34;: return eflags_dic[\u0026#34;ZF\u0026#34;] == 1 elif jumps_type == \u0026#34;jg\u0026#34;: return eflags_dic[\u0026#34;ZF\u0026#34;] == 0 and eflags_dic[\u0026#34;SF\u0026#34;] == eflags_dic[\u0026#34;OF\u0026#34;] elif jumps_type == \u0026#34;jge\u0026#34;: return eflags_dic[\u0026#34;SF\u0026#34;] == eflags_dic[\u0026#34;OF\u0026#34;] elif jumps_type == \u0026#34;jl\u0026#34;: return eflags_dic[\u0026#34;SF\u0026#34;] != eflags_dic[\u0026#34;OF\u0026#34;] elif jumps_type == \u0026#34;jle\u0026#34;: return eflags_dic[\u0026#34;ZF\u0026#34;] == 1 or eflags_dic[\u0026#34;SF\u0026#34;] != eflags_dic[\u0026#34;OF\u0026#34;] elif jumps_type == \u0026#34;jna\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 1 or eflags_dic[\u0026#34;ZF\u0026#34;] == 1 elif jumps_type == \u0026#34;jnae\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 1 elif jumps_type == \u0026#34;jnb\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 0 elif jumps_type == \u0026#34;jnbe\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 0 and eflags_dic[\u0026#34;ZF\u0026#34;] == 0 elif jumps_type == \u0026#34;jnc\u0026#34;: return eflags_dic[\u0026#34;CF\u0026#34;] == 0 elif jumps_type == \u0026#34;jne\u0026#34; or jumps_type == \u0026#34;jnz\u0026#34;: return eflags_dic[\u0026#34;ZF\u0026#34;] == 0 elif jumps_type == \u0026#34;jno\u0026#34;: return eflags_dic[\u0026#34;OF\u0026#34;] == 0 elif jumps_type == \u0026#34;jnp\u0026#34; or jumps_type == \u0026#34;jpo\u0026#34;: return eflags_dic[\u0026#34;PF\u0026#34;] == 0 elif jumps_type == \u0026#34;jns\u0026#34;: return eflags_dic[\u0026#34;SF\u0026#34;] == 0 elif jumps_type == \u0026#34;jo\u0026#34;: return eflags_dic[\u0026#34;OF\u0026#34;] == 1 elif jumps_type == \u0026#34;jp\u0026#34; or jumps_type == \u0026#34;jpe\u0026#34;: return eflags_dic[\u0026#34;PF\u0026#34;] == 1 elif jumps_type == \u0026#34;js\u0026#34;: return eflags_dic[\u0026#34;SF\u0026#34;] == 1 elif jumps_type == \u0026#34;jmp\u0026#34;: return 1 # Default case if jump type not recognized return False # address from x64 main_addr = 0x00007FF6B1F51070 control_flow_start = 0x00007FF6B1F524D0 wrong_condition_addr = [0x00007FF6B1F53901, 0x00007FF6B1F53866, 0x00007FF6B1F53652, 0x00007FF6B1F5355F, 0x00007FF6B1F53350, 0x00007FF6B1F532B3, 0x00007FF6B1F53211, 0x00007FF6B1F530E1, 0x00007FF6B1F52EFE, 0x00007FF6B1F52E4C, 0x00007FF6B1F52D18, 0x00007FF6B1F52AD4, 0x00007FF6B1F5281D, 0x00007FF6B1F5279A, 0x00007FF6B1F52635, 0x00007FF6B1F52566, 0x00007FF6B1F54B66, 0x00007FF6B1F54971, 0x00007FF6B1F54865, 0x00007FF6B1F54841, 0x00007FF6B1F547BC, 0x00007FF6B1F5419A, 0x00007FF6B1F5414E, 0x00007FF6B1F53F5D, 0x00007FF6B1F53BC1, 0x00007FF6B1F53B09, 0x00007FF6B1F53A61, 0x00007FF6B1F53A46, 0x00007FF6B1F53D12, 0x00007FF6B1F53CE1, 0x00007FF6B1F53E2E, 0x00007FF6B1F54D4E] dp.start(main_addr, control_flow_start) solve_dict = {} current_control_flow_value = dp.regs.rax counter = 0 new_val_rax = 0 while True: instr = map_to_ida(control_flow_start) instr_code = get_assembly(instr) next_instr = idc.next_head(instr) eflags = int(dp.regs.eflags) control_flow_start = next_instr # it\u0026#39;s end of the program if map_to_x_64(dp.regs.rip) == 0x00007FF6B1F54D4E: print(\u0026#34;It\u0026#39;s Ennnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnd\u0026#34;) print(solve_dict) break # moving to a new equation if map_to_x_64(dp.regs.rip) in wrong_condition_addr: print(\u0026#34;wronnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnng condition\u0026#34;) temp = instr key = \u0026#34;eq\u0026#34; + str(counter) while True: if get_assembly(temp).split(\u0026#34; \u0026#34;)[0] == \u0026#34;jmp\u0026#34;: current_control_flow_value = solve_dict[key][-1].split(\u0026#34;=\u0026#34;)[-1][:-4][2:] convert_to_little_endian = pack(\u0026#39;\u0026lt;Q\u0026#39;, int.from_bytes(bytes.fromhex(current_control_flow_value), byteorder=\u0026#39;big\u0026#39;)) new_val_rax = bytes.fromhex(\u0026#34;48B8\u0026#34;) + convert_to_little_endian control_flow_start = get_addr_of_loc(get_assembly(temp)) break res = pseudo_for_ea(temp) if key in solve_dict: if res not in solve_dict[key]: solve_dict[key].append(res) else: solve_dict[key] = [res] temp = idc.next_head(temp) print(\u0026#34;equationnnnnnnnnnnnnnnnnnnnnnns Wronnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnng:\u0026#34;, key, solve_dict[key]) counter += 1 # if the jump is taken we must change the address of the next instruction elif instr_code.split(\u0026#34; \u0026#34;)[0] in jumps: print(\u0026#34;jump conditionnnnnnnnnnnnnnnnnnn\u0026#34;) if instr_code.split(\u0026#34; \u0026#34;)[0] == \u0026#34;jmp\u0026#34;: print(\u0026#34;jump takennnnnnnnnnnnnnnnnn\u0026#34;) control_flow_start = get_addr_of_loc(get_assembly(instr)) continue yes_or_no = is_jump_taken(instr_code, dp.regs.eflags) if yes_or_no: print(\u0026#34;jump takennnnnnnnnnnnnnnnnn\u0026#34;) control_flow_start = get_addr_of_loc(get_assembly(instr)) else: print(\u0026#34;jump nottttttttttttttttttttttttttt taken\u0026#34;) # add a part of the equation elif \u0026#34;cmp\u0026#34; not in instr_code and instr_code.split(\u0026#34; \u0026#34;)[0] not in jumps: print(\u0026#34;operationnnnnnnnnnnnnnnnnnnnnnnnnnnn\u0026#34;) temp = instr while True: if get_assembly(temp).split(\u0026#34; \u0026#34;)[0] == \u0026#34;jmp\u0026#34;: current_control_flow_value = solve_dict[counter][-1].split(\u0026#34;=\u0026#34;)[-1][:-4][2:] convert_to_little_endian = pack(\u0026#39;\u0026lt;Q\u0026#39;, int.from_bytes(bytes.fromhex(current_control_flow_value), byteorder=\u0026#39;big\u0026#39;)) new_val_rax = bytes.fromhex(\u0026#34;48B8\u0026#34;) + convert_to_little_endian control_flow_start = get_addr_of_loc(get_assembly(temp)) break elif map_to_x_64(temp) in wrong_condition_addr: control_flow_start = temp break res = pseudo_for_ea(temp) if counter in solve_dict: if res not in solve_dict[counter]: solve_dict[counter].append(res) else: solve_dict[counter] = [res] temp = idc.next_head(temp) print(\u0026#34;equationnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnns:\u0026#34;, counter, solve_dict[counter]) print(\u0026#34;Control Flow:\u0026#34;, hex(dp.regs.rax)) print(\u0026#34;Current RIP: \u0026#34;, hex(instr)) print(\u0026#34;next RIP:\u0026#34;, hex(control_flow_start)) print(\u0026#34;instr:\u0026#34;, instr_code) print(\u0026#34;Counter Equations:\u0026#34;, counter) print(\u0026#34;-\u0026#34;*20) dp = Dumpulator(\u0026#34;night.dmp\u0026#34;, quiet=True) if new_val_rax != 0: # patch the value of rax dp.write( map_to_x_64(0x11FD), new_val_rax) dp.start(main_addr, map_to_x_64(control_flow_start)) if counter == 6: break Astra Let\u0026rsquo;s begin by examining the main function. Initially, it prints the message Enter The Flag: and waits for our input. Afterward, it executes the function sub_401090(). You can see in the gif, we observe that this function appears to be ntdll_RtlAddVectoredExceptionHandler. The next function called is ntdll_RtlAddVectoredExceptionHandler, with two parameters being passed: 1 and check_the_flag.\nLet\u0026rsquo;s see ntdll_RtlAddVectoredExceptionHandler at msdn.\nntdll_RtlAddVectoredExceptionHandler\rcheck_the_flag\rSummary\rntdll_RtlAddVectoredExceptionHandler 1 2 3 4 PVOID AddVectoredExceptionHandler( ULONG First, PVECTORED_EXCEPTION_HANDLER Handler ); First\nThe order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.\nHander AKA check_the_flag\nA pointer to the handler to be called. For more information, see VectoredHandler.\nLet\u0026rsquo;s edit the function parameters type in IDA\ncheck_the_flag 1 2 3 4 5 6 PVECTORED_EXCEPTION_HANDLER PvectoredExceptionHandler; LONG PvectoredExceptionHandler( [in] _EXCEPTION_POINTERS *ExceptionInfo ) {...} A pointer to an EXCEPTION_POINTERS structure that receives the exception record.\nNote that the _EXCEPTION_POINTERS contains two struct\nExceptionRecord ContextRecord\nHe used ContextRecord to get the values of registers and so on\u0026hellip;. Summary First Case Set the register ecx with value 0x15 (which is used in check_the_flag to determine which case will be taken), then it divide by zero so that the excpetion will happend and call check_the_flag function.\nThe instruction v29-\u0026gt;Eip += 2; -\u0026gt; is used to escape the idiv and avoid getting trapped in a continuous loop, and then it set the memory\nSecond Case Move `dword`` of our input to the eax register. Set ecx 0xA (which is used in check_the_flag to determine which case will be taken), then it divide by zero so that the excpetion will happend and call check_the_flag function\nv23 = ContextRecord-\u0026gt;Eax; -\u0026gt; which is a dword of our input\nAfterwards, the program stores the resulting value at a specific memory location.\nFor example, if the op_code is equal to 0x30210, the movzx operation will only consider 0x10 and evaluate which op_code satisfies the condition: dword_7D7370[(Ecx \u0026gt;\u0026gt; 8) \u0026amp; 7] = v23;. In this case, the operation is performed on 0x30210, resulting in (0x30210 \u0026gt;\u0026gt; 8) \u0026amp; 7 = 2.\nNow, our next step is to extract all the op_codes and addresses where they access the user input. This information will be necessary for emulation using dumpulator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import idaapi import idc get_assembly = lambda x: idc.GetDisasm(x) def dump_op(start, end): temp = start val = {\u0026#34;start\u0026#34;: [], \u0026#34;end\u0026#34;: [], \u0026#34;ecx\u0026#34;: []} while temp != end: instr_code = get_assembly(temp) if \u0026#34;mov ecx\u0026#34; in instr_code and \u0026#34;[ebp+var_4]\u0026#34; not in instr_code: hex_val = instr_code.split(\u0026#34;,\u0026#34;)[-1].replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;h\u0026#34;, \u0026#34;\u0026#34;) val[\u0026#39;start\u0026#39;].append(idc.prev_head(temp) if \u0026#34;mov eax\u0026#34; in get_assembly(idc.prev_head(temp)) else \u0026#34;\u0026#34;) val[\u0026#39;end\u0026#39;].append(idc.next_head(temp)) val[\u0026#39;ecx\u0026#39;].append(hex_val) temp = idc.next_head(temp) return val start_main = 0x00B91DE0 # start address of the main end_main = 0x00B94CC6 # end address of the main get_all_op = dump_op(start_main, end_main) print(get_all_op) Now that we have obtained the opcodes, the next step is to acquire the dump file (dmp) required for the emulation process.\nHere is the VM disassembler and the result\nVM disassembler\rResult\rVM disassembler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 from op_value import * from dumpulator import Dumpulator split_hex = lambda hex_ecx: [int(\u0026#34;0x\u0026#34; + hex_ecx[i:i+2], 16) for i in range(0, len(hex_ecx), 2)] to_hex = lambda val: int(\u0026#34;0x\u0026#34;+val, 16) convert_arr = lambda lst: \u0026#39;\u0026#39;.join([hex(num)[2:] for num in lst]) map_to_x64 = lambda addr, base: int(\u0026#34;0x\u0026#34; + base + hex(addr)[2:][-4:], 16) format_4 = lambda val: [\u0026#34;\u0026#34;.join((val[i:i+4])) for i in range(0, len(val), 4)] hex_arr = lambda lst: [f\u0026#34;%.2x\u0026#34; % num for num in lst] base = \u0026#34;38\u0026#34; # if the ida base is different from your dump base, change it here memory = [] with open(\u0026#34;astra.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: for i, ecx in enumerate(op[\u0026#39;ecx\u0026#39;]): if ecx[-2:] == \u0026#34;15\u0026#34;: # set memory to 0 memory = [0 for i in range(32)] # 7 * 4(dword) = 28 -\u0026gt; 32 bytes increase the size to esacpe the index out of range error in case \u0026#34;12\u0026#34; f.write(f\u0026#34;{ecx[-2:]}: setting memory to 0 -\u0026gt;\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) elif ecx[-2:] == \u0026#34;0A\u0026#34;: # mov memory, eax_val dp = Dumpulator(\u0026#34;astra.dmp\u0026#34;, quiet=True) dp.start(map_to_x64(op[\u0026#39;start\u0026#39;][i], base), map_to_x64(op[\u0026#39;end\u0026#39;][i], base)) eax_val = hex(dp.regs.eax)[2:] store_mem_index = (to_hex(ecx) \u0026gt;\u0026gt; 8) \u0026amp; 7 memory[store_mem_index*4:store_mem_index*4+4] = split_hex(eax_val) f.write(f\u0026#34;{ecx[-2:]}: mov memory[{store_mem_index*4}:{store_mem_index*4+4}]_index_{store_mem_index}, eax_value_{eax_val} -\u0026gt;\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) elif ecx[-2:] == \u0026#34;16\u0026#34;: # mov memory, memory index_v24 = (to_hex(ecx) \u0026gt;\u0026gt; 0x10) \u0026amp; 7 value_v24 = memory[index_v24*4:index_v24*4+4] store_mem_index = (to_hex(ecx) \u0026gt;\u0026gt; 8) \u0026amp; 7 memory[store_mem_index*4:store_mem_index*4+4] = value_v24 f.write(f\u0026#34;{ecx[-2:]}: mov memory[{store_mem_index*4}:{store_mem_index*4+4}]_index_{store_mem_index}, memory_at_index_{index_v24}_{convert_arr(memory[index_v24*4:index_v24*4+4])} -\u0026gt;\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) if ecx[-2:] == \u0026#34;10\u0026#34;: # xor operation get_index_1 = (to_hex(ecx) \u0026gt;\u0026gt; 8) \u0026amp; 7 get_val_1 = memory[get_index_1*4:get_index_1*4+4] get_index_2 = (to_hex(ecx) \u0026gt;\u0026gt; 0x10) \u0026amp; 7 get_val_2 = memory[get_index_2*4:get_index_2*4+4] xor_res = [get_val_1[i] ^ get_val_2[i] for i in range(4)] memory[get_index_1*4:get_index_1*4+4] = xor_res f.write(f\u0026#34;{ecx[-2:]}: xor memory[{get_index_1*4}:{get_index_1*4+4}]_index_{get_index_1}, memory_at_index_{get_index_2}_{convert_arr(get_val_2)} -\u0026gt;\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) if ecx[-2:] == \u0026#34;12\u0026#34;: # or operation get_index_1 = (to_hex(ecx) \u0026gt;\u0026gt; 8) \u0026amp; 7 get_val_1 = memory[get_index_1*4:get_index_1*4+4] get_index_2 = (to_hex(ecx) \u0026gt;\u0026gt; 0x10) \u0026amp; 7 get_val_2 = memory[get_index_2*4:get_index_2*4+4] or_res = [get_val_1[i] | get_val_2[i] for i in range(4)] memory[get_index_1*4:get_index_1*4+4] = or_res f.write(f\u0026#34;{ecx[-2:]}: or memory[{get_index_1*4}:{get_index_1*4+4}]_index_{get_index_1}, memory_at_index_{get_index_2}_{convert_arr(get_val_2)} -\u0026gt;\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) if ecx[-2:] == \u0026#34;13\u0026#34;: # check the flag -\u0026gt; if a dword is equal to zero then it\u0026#39;s the correct flag f.write(f\u0026#34;check the flag, does the last 4 bytes is zero or not?\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[:16]))}\\n\u0026#34;) f.write(f\u0026#34;{format_4(hex_arr(memory[16:]))}\\n\\n\u0026#34;) Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 15: setting memory to 0 -\u0026gt; [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] 0A: mov memory[0:4]_index_0, eax_value_33323130 -\u0026gt; [\u0026#39;33323130\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] 0A: mov memory[4:8]_index_1, eax_value_37363534 -\u0026gt; [\u0026#39;33323130\u0026#39;, \u0026#39;37363534\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] 0A: mov memory[8:12]_index_2, eax_value_33323130 -\u0026gt; [\u0026#39;33323130\u0026#39;, \u0026#39;37363534\u0026#39;, \u0026#39;33323130\u0026#39;, \u0026#39;00000000\u0026#39;] [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] 0A: mov memory[12:16]_index_3, eax_value_37363534 -\u0026gt; [\u0026#39;33323130\u0026#39;, \u0026#39;37363534\u0026#39;, \u0026#39;33323130\u0026#39;, \u0026#39;37363534\u0026#39;] [\u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;, \u0026#39;00000000\u0026#39;] ................ ................ ................ Now, you can see the instructions generated by our VM disassembler, and solve the challenge ðŸ™‚\nAnother amazing solution made by my friend\n","description":"MTC-CTF is an exciting and challenging CTF competition brought to you by the Military Technical College (MTC) and the Egyptian Computer Emergency Readiness Team (EG|CERT).","id":1,"section":"ctfs","tags":["writeUps","REV","dumpulator"],"title":"ICMTC Reverse","uri":"https://s00ra.github.io/ctfs/icmtcrev/"},{"content":"Introduction Some source language has a significant impact on the assembly. For example, C++ has several features and constructs that do not exist in C, and these can complicate analysis of the resulting assembly.\nMalicious programs written in C++ create challenges for the malware analyst that make it harder to determine the purpose of assembly code. Understanding basic C++ features and how they appear in assembly language is critical to analyzing malware written in C++.\nIn order to understand C++ concepts as they are represented in dis-assemblies, you must be able to:\nIdentify the classes Identify relationships between classes Identify the class members Scratching The Service OOP C and C++ are both procedural programming languages, but C++ is an object-oriented programming (OOP) language as well. This means that C++ includes additional features such as classes, objects, inheritance, polymorphism, and templates, which are not present in C.\nClasses are like structs, except that they store function information in addition to data. Classes provide a way to define custom data types with their own properties (data members) and behaviors (member functions) that can be used to create objects.\nIn this example, the class is called SimpleClass. It has one data member, x, and a single function, HelloWorld. We create an instance of SimpleClass named myObject and call the HelloWorld function for that object.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; class SimpleClass { public: int x; // data member // member functions void HelloWorld() { printf(\u0026#34;Hello World\\n\u0026#34;); } }; int main() { // custome data type SimpleClass myObject; myObject.HelloWorld(); } Overloading and Mangling Function overloading is a feature C++ that allows multiple functions with the same name, but that accept different parameters. When the function is called, the compiler determines which version of the function to use based on the number and types of parameter used in the call, as shown in c++ code and picture below.\nin the c++ code, three functions do the same thing; adding all parameters and printing the result. If we look at the picture below, we can notice that it\u0026rsquo;s __cdecl calling convention where function parameters are pushed onto the stack in reverse order, i.e., the rightmost parameter is pushed first, so the first function call there was only when the variable pushed on the stack and in the second call two variable are pushed on the stack and so on\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; void sum(int num1) { cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; } void sum(int num1, int num2) { cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; num1 + num2 \u0026lt;\u0026lt; endl; } void sum(int num1, int num2, int num3) { cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; num1 + num2 + num3 \u0026lt;\u0026lt; endl; } int main() { sum(1); sum(1, 2); sum(1, 2, 3); return 0; } C++ uses a technique called name mangling to support method overloading. In the PE file format, each function is labeled with only its name, and the function parameters are not specified in the compiled binary format. To support overloading, the names in the file format are modified so that the name information includes the parameter information. For example, in the picture above we can notice that sum function are called __Z3sumi where i represent the number of parameters are passed.\nIDA Pro can de-mangle the names for most compiler.\n\u0026nbsp;\r\u0026nbsp;\u0026nbsp;\r\u0026nbsp;\rThe internal function names are visible only if there are symbols in the code you are analyzing. Malware usually has the internal symbols removed :)\rExample Tools: It\u0026rsquo;s not related to the challenge, but I would like to mention ClassInformer. It was used as a VTable finder, and I remember my first time using it in Flare-On 9 Challenge 5. It saved me a lot of time in reverse engineering Easy C++ Challenge [FlagYard - tables] Challenge Link Static Analysis When dealing with C++ binaries, one common challenge is the presence of mangled names. C++ compilers use name mangling to encode information about a function\u0026rsquo;s parameters and return type into its name as we discussed. We can use the \u0026ldquo;Demangled names\u0026rdquo; option in IDA to remove the mangled names.\n\u0026nbsp;\rBy looking at the main function it ask for the Flag and store it in variable s. Then it allocates 8 bytes of memory using the operator new function and assigns the pointer to the newly allocated memory to a variable named v6. The memset function is then used to set all the bytes of the allocated memory to 0. After the memory has been allocated and initialized, a function named sub_401350 is called with v6 as its argument.\nIn brief, the code in the function sub_401350 sets the pointer v6 to the address of the virtual function table (vtable) for the class P0.\nWhen I scrolled down to examine the vtables, I noticed that there were a total of 44 vtables present in the program, denoted as P[0-43]. I noticed that this is the exact number of iterations in the for-loop that followed.\nBased on this, I made a guess that there may be a vtable for each character of the Flag, make a check or something else !!!\nUpon inspecting function sub_401390, it can be observed that it contains a switch case statement that checks the user input character. Depending on the value of this character, the program jumps to a specific function within the P0 class as we pass a pointer v8 to the vtable of P0\n\u0026nbsp;\u0026nbsp;\rDebugging Time Soooo we already know the flag format, which is FlagY{}. Letâ€™s set a breakpoint on the function sub_401390 in the for loop and letâ€™s run the program. We input FlagY{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} as a flag.\nWe notice that if itâ€™s a correct character the return value which is stored in rax is an pointer to the vtable of the next P[N] and if itâ€™s a wrong character it return a pointer to vtable of letters\nAfter completing the loop, the final step is to verify if our input is correct. This can be achieved by checking the last value of **RAX**. If the pointer points to a **vtable of letters**, then the flag is incorrect. However, if it points to the address of P43, then the flag is correct.\nTo validate this approach, we can input any value and when the program reaches the checking part, the value can be edited to the address of **class P43**, which is 0x4084A0. Upon doing so, the correct message will be displayed.\nWe can grab all the values of the addresses from P1 to P43, and we can check if the character we input is correct or wrong by comparing the value in rax with the array we created of addresses P[0-43]. If it points to the next P[N], it will be the correct character else. We continue brute-forcing until we get the flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import gdb def write_txt(val): with open(\u0026#34;attempt.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(val) def write_end(val): with open(\u0026#34;end.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(val) FLAG_LEN = 43 known_flag = \u0026#34;FlagY{\u0026#34; possible_char = \u0026#39;0123456789_abcdefghijklmnopqrstuvwxyz}\u0026#39; # characters from switch case (remove known part [F-Y-{]) # v-table P[1-43] offsets -\u0026gt; 0x4045A0: P1 offset # The difference between each offset is 384 success = [f\u0026#39;0x%.2x\u0026#39; % i for i in range(0x4045A0, 0x4045A0 + (43 * 384), 384)] gdb.execute(\u0026#39;b *0x4012C1\u0026#39;) # break on rax value to check the v-table addr gdb.execute(\u0026#39;set confirm off\u0026#39;) # to close confirmation message when you kill the program write_end(str(6)) # 6 -\u0026gt; start at index 6 =\u0026gt; FlagY{? while len(known_flag) != 43: for i, char in enumerate(possible_char): # loop through each possible character until we get the correct one bf = known_flag + char + \u0026#39;a\u0026#39; * (43 - len(known_flag) - 2) + \u0026#39;}\u0026#39; # brute-force ( we sub 2 from the len -\u0026gt; ( \u0026#39;char\u0026#39; and \u0026#39;}\u0026#39; ) ) end = int( open(\u0026#39;end.txt\u0026#39;, \u0026#39;r\u0026#39;).read() ) # current index that we are bruteforcing write_txt(bf) gdb.execute(\u0026#34;run \u0026lt;attempt.txt \u0026gt;/dev/null\u0026#34;) for _ in range(end): gdb.execute(\u0026#39;continue\u0026#39;) x = hex(int( gdb.execute(\u0026#39;x /2wd $rax\u0026#39;, to_string=True).split()[1] )) if x == success[end]: print(\u0026#34;-------------------------------------[success]-----------------------------\u0026#34;, bf[end]) known_flag += char print(\u0026#34;-------------------------------------[FLAG]-----------------------------\u0026#34;, known_flag) end += 1 write_end(str(end)) gdb.execute(\u0026#39;kill\u0026#39;) break else: print(f\u0026#34;-------------[LOADING]---------------------- {i} {len(known_flag)}/43\u0026#34;) gdb.execute(\u0026#39;kill\u0026#39;) print(\u0026#34;Doneeeee!!!!!!!!!!!!!!!!!!\u0026#34;, bf) References Practical Malware Analysis Book Chapter 20: C++ Analysis Virtual Inheritance In C++ Binaries OpenSecurityTraining2:Â RE3011Reverse Engineering 3011: Reversing C++ Binaries Reversing C++ ","description":"C++ Binaries are full of mysteries, they have objects, inheritance, templates, vtables and many more and reverse engineering them is a task on its own. In order to correctly and clearly map a C++ compiled binary it requires a vast knowledge of C++ Internals.","id":2,"section":"gt","tags":["writeUps","Flagyard","c++","General Topics"],"title":"Tables","uri":"https://s00ra.github.io/gt/tables/"},{"content":"\rHello and welcome to my reverse engineering and machine learning write-up. This was my first time participating in Cyber Apocalypse 2023 - The Cursed Mission, and it was an incredibly fun experience. I had the pleasure of working with IDEK team, and I'm happy to say that we managed to achieve ðŸ¥‡ **1st** place in the competition.\r1ï¸âƒ£ CHALLEGNE NAME: Shattered Tablet\nDifficulty: Very easy\nDeep in an ancient tomb, you\u0026rsquo;ve discovered a stone tablet with secret information on the locations of other relics. However, while dodging a poison dart, it slipped from your hands and shattered into hundreds of pieces. Can you reassemble it and read the clues? We started with the first challenge by loading it into IDA. Itâ€™s consisting of a single if condition checking each character of the input and comparing it with the flag. Rather than manually analyzing each condition and sorting it out, we opted to use symbolic execution to get the flag quickly and easily. As a result, we were able to retrieve the flag without any significant effort.\nOR\nBYTE4(),BYTE3(),BYTE2(), and BYTE1() are macros that extract the fourth, third, second, and first byte of a 32-bit integer, respectively. So we can concatenate all these bytes and we will have the Flag s = HTB{br0k, v5 = 3n_4p4rt, v6 = ,n3ver_t, v7 = **0_b3_r3p**, and v8 = **41r3d}**\n\u0026nbsp;\r1 2 3 4 5 6 7 8 9 10 11 12 import angr # load the binary project = angr.Project(\u0026#39;tablet\u0026#39;, load_options={\u0026#34;auto_load_libs\u0026#34;: False}) # store the entry path pathgroup = project.factory.simgr() # Create a simulation engine with symbolic values sm = project.factory.simulation_manager() print( sm.explore( find=lambda s:b\u0026#34;Yes! That\u0026#39;s right!\u0026#34; in s.posix.dumps(1) ) ) print(sm.found[0].posix.dumps(0)) # flag = str(pathgroup.active[0].posix.dumps(0))[2:-1] flag = str(sm.found[0].posix.dumps(0)) print(flag) ðŸš© HTB{br0k3n_4p4rt,n3ver_t0_b3_r3p41r3d}\r2ï¸âƒ£ CHALLEGNE NAME: She Shells C Shells\nDifficulty: Very easy\nYou\u0026rsquo;ve arrived in the Galactic Archive, sure that a critical clue is hidden here. You wait anxiously for a terminal to boot up, hiding in the shadows from the guards hunting for you. Unfortunately, it looks like you\u0026rsquo;ll need a password to get what you need without setting off the alarms\u0026hellip; Moving on to the second challenge, we loaded it into IDA and looking for strings. We found the string \"Flag: %s\\n\", and letâ€™s investigate the function responsible for it.â€\r\u0026nbsp;\u0026nbsp;\r\u0026nbsp;\rThe function takes user input then loops through 74 characters, which is the length of the flag, and XORs each character with \u0026lsquo;m1\u0026rsquo;. The result is then compared with \u0026rsquo;t\u0026rsquo; if itâ€™s correct we will get the flag.\nSo itâ€™s simply and XOR challenge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import xor t = [ 0x2C, 0x4A, 0xB7, 0x99, 0xA3, 0xE5, 0x70, 0x78, 0x93, 0x6E, 0x97, 0xD9, 0x47, 0x6D, 0x38, 0xBD, 0xFF, 0xBB, 0x85, 0x99, 0x6F, 0xE1, 0x4A, 0xAB, 0x74, 0xC3, 0x7B, 0xA8, 0xB2, 0x9F, 0xD7, 0xEC, 0xEB, 0xCD, 0x63, 0xB2, 0x39, 0x23, 0xE1, 0x84, 0x92, 0x96, 0x09, 0xC6, 0x99, 0xF2, 0x58, 0xFA, 0xCB, 0x6F, 0x6F, 0x5E, 0x1F, 0xBE, 0x2B, 0x13, 0x8E, 0xA5, 0xA9, 0x99, 0x93, 0xAB, 0x8F, 0x70, 0x1C, 0xC0, 0xC4, 0x3E, 0xA6, 0xFE, 0x93, 0x35, 0x90, 0xC3, 0xC9, 0x10, 0xE9 ] m1 = [ 0x6E, 0x3F, 0xC3, 0xB9, 0xD7, 0x8D, 0x15, 0x58, 0xE5, 0x0F, 0xFB, 0xAC, 0x22, 0x4D, 0x57, 0xDB, 0xDF, 0xCF, 0xED, 0xFC, 0x1C, 0x84, 0x6A, 0xD8, 0x1C, 0xA6, 0x17, 0xC4, 0xC1, 0xBF, 0xA0, 0x85, 0x87, 0xA1, 0x43, 0xD4, 0x58, 0x4F, 0x8D, 0xA8, 0xB2, 0xF2, 0x7C, 0xA3, 0xB9, 0x86, 0x37, 0xDA, 0xBF, 0x07, 0x0A, 0x7E, 0x73, 0xDF, 0x5C, 0x60, 0xAE, 0xCA, 0xCF, 0xB9, 0xE0, 0xDE, 0xFF, 0x00, 0x70, 0xB9, 0xE4, 0x5F, 0xC8, 0x9A, 0xB3, 0x51, 0xF5, 0xAE, 0xA8, 0x7E, 0x8D ] password = xor(t, m1) print(password) # output: b\u0026#39;But the value of these shells will fall, due to the laws of supply and demand\u0026#39; ðŸš© HTB{cr4ck1ng_0p3n_sh3ll5_by_th3_s34_sh0r3}\r3ï¸âƒ£ CHALLEGNE NAME: Hunting License\nDifficulty: Easy\nSTOP! Adventurer, have you got an up to date relic hunting license? If you don\u0026rsquo;t, you\u0026rsquo;ll need to take the exam again before you\u0026rsquo;ll be allowed passage into the spacelanes! As we move on to the next challenge, we found \u0026ldquo;0wTdr0wss4P\u0026rdquo; in strings on IDA. This string is located within the exam() function. It\u0026rsquo;s possible that this string could be a password, so we letâ€™s see the function to see what else we can find.\n\u0026nbsp;\r\u0026nbsp;\rchallenge, requiring us to obtain three passwords!\nFirst password is very obvious: PasswordNumeroUno As for the second password, we have already located 0wTdr0wss4P, but we need to reverse it! ðŸ™‚. The second password is now revealed to be P4ssw0rdTw0 The third and final one is just XORing the value in address \u0026amp;t2 with 19 after going inside the function and checking what parameters are used for, and the result is ThirdAndFinal!!!\n\u0026nbsp;\r\u0026nbsp;\u0026nbsp;\r\u0026nbsp;\rðŸš© HTB{l1c3ns3_4cquir3d-hunt1ng_t1m3!} 4ï¸âƒ£ CHALLEGNE NAME: Cave System\nDifficulty: Easy\nDeep inside a cave system, 500 feet below the surface, you find yourself stranded with supplies running low. Ahead of you sprawls a network of tunnels, branching off and looping back on themselves. You don\u0026rsquo;t have time to explore them all - you\u0026rsquo;ll need to program your cave-crawling robot to find the way outâ€¦ The next challenge involve an single if condition that check the input and performing operations such as multiplying the first and second values and comparing the result with a fixed value. Although it can be solved using the Z3 solver, it may take some time to manually copy all the values and replace the BYTE_i() function with the appropriate text index. As an alternative, solving this challenge using symbolic execution would be much easier and efficient.\n1 2 3 4 5 6 7 8 9 10 11 12 import angr # load the binary project = angr.Project(\u0026#39;cave\u0026#39;, load_options={\u0026#34;auto_load_libs\u0026#34;: False}) # store the entry path pathgroup = project.factory.simgr() # Create a simulation engine with symbolic values sm = project.factory.simulation_manager() print( sm.explore( find=lambda s:b\u0026#34;Freedom at last!\u0026#34; in s.posix.dumps(1) ) ) print(sm.found[0].posix.dumps(0)) # flag = str(pathgroup.active[0].posix.dumps(0))[2:-1] flag = str(sm.found[0].posix.dumps(0)) print(flag) \u0026nbsp;\u0026nbsp;\rðŸš© HTB{H0p3_u_d1dn\u0026rsquo;t_g3t_th15_by_h4nd,1t5_4_pr3tty_l0ng_fl4g!!!} 5ï¸âƒ£ CHALLEGNE NAME: Alien Saboteaur\nDifficulty: Medium\nYou finally manage to make it into the main computer of the vessel, it\u0026rsquo;s time to get this over with. You try to shutdown the vessel, however a couple of access codes unknown to you are needed. You try to figure them out, but the computer start speaking some weird language, it seems like gibberish\u0026hellip; Walkthrough Now let\u0026rsquo;s move on to the serious stuff. The VM obfuscation challenge. We have two files, vm and bin, and we can execute them by typing\n1 $ ./vm bin \u0026nbsp;\u0026nbsp;\rThe bin file contains bytecode that is compiled using the vm file. Therefore, let\u0026rsquo;s load the vm file into IDA. The program first opens the bin file and retrieves the size of the file and a pointer to its contents.\nThe vm_create() function takes two parameters: \u0026ldquo;bin_ptr\u0026rdquo; and \u0026ldquo;bin_size\u0026rdquo;. The function first allocates 168 bytes of memory for a variable called \u0026ldquo;v3\u0026rdquo;, which is used to store the state of the virtual machine.\nThe function then initializes various fields of the \u0026ldquo;v3\u0026rdquo; variable. It also allocates memory for two additional variables: a 64KB block of memory and a 800-byte block of memory, which are maybe used for the virtual machine\u0026rsquo;s memory and stack, respectively.\nThe function then copies the contents of the \u0026ldquo;bin\u0026rdquo; file, starting from the fourth byte (i.e., skipping the first three bytes, which are 55 77 55), into the 64KB block of memory allocated.\n\u0026nbsp;\r\u0026nbsp;\rThe vm_run() function is responsible for executing the bytecode contained in the virtual machine\u0026rsquo;s memory. The function takes a single parameter, \u0026ldquo;a1\u0026rdquo;, which is a pointer to the virtual machine state.\nThe function works by repeatedly calling the vm_step() function.\n\u0026nbsp;\r\u0026nbsp;\rThe vm_step() function is given the virtual machine code and it decompiles each bytecode instruction using a vtable of instruction functions called original_ops, which are accessed based on the current bytecode index.\nThe vm_step() function fetches the current bytecode using the expression *( *(a1 + 18) + *a1 ) and calls the corresponding function using the expression (original_ops[v2])(a1). If the bytecode index is greater than 0x19, the maximum number of instructions defined in the original_ops array, the program exits with an error message \u0026ldquo;dead\u0026rdquo;.\nWriting The Decompiler When writing a Decompiler, it\u0026rsquo;s IMP to understand how the vm_\u0026lt;inst\u0026gt; processes the parameters. For example, if you have a series of hex values such as [0x10, 0x5b, 0x00, 0x00, 0x00, 0x00], this indicate that the instruction is pushing the value 0x5b onto the stack. If you see a series of hex values like ['0c', '1e', 'a0', '0f'], this means that the instruction is moving the value 0xfa0 into the register at offset 0x1e. By analyzing the sequence of instructions and their corresponding parameters, you can understand of how the program is work.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 # bc: byte_code :) vm_bc = open(\u0026#34;bin\u0026#34;, \u0026#34;rb\u0026#34;).read()[3:] # escape the first 3 bytes # NOTE THAT SOME INSTRUCTIONS AREN\u0026#39;T USED, SO I WILL NOT WRITE \u0026lt;IF STATEMENTS\u0026gt; FOR THEM inst = [ \u0026#39;add\u0026#39;, \u0026#39;addi\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;subi\u0026#39;, \u0026#39;mul\u0026#39;, \u0026#39;muli\u0026#39;, \u0026#39;div\u0026#39;, \u0026#39;cmp\u0026#39;, \u0026#39;jmp\u0026#39;, \u0026#39;inv\u0026#39;, \u0026#39;push\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;mov\u0026#39;, \u0026#39;nop\u0026#39;, \u0026#39;exit\u0026#39;, \u0026#39;print\u0026#39;, \u0026#39;putc\u0026#39;, \u0026#39;je\u0026#39;, \u0026#39;jne\u0026#39;, \u0026#39;jle\u0026#39;, \u0026#39;jge\u0026#39;, \u0026#39;xor\u0026#39;, \u0026#39;store\u0026#39;, \u0026#39;load\u0026#39;, \u0026#39;input\u0026#39; ] # if you went to any vm_\u0026lt;inst\u0026gt; for example vm_putc # you will find that it add 6 to the pointer a1 # *a1 += 6; with open(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: for i in range(0, len(vm_bc), 6): bc = [i for i in vm_bc[i:i+6] if i != 0] # byte_code final_res = \u0026#34;\u0026#34; if len(bc) == 0: f.write(f\u0026#34;finish ?????????????????????\\n\u0026#34;) continue if bc[0] \u0026gt;= 0x19: # DEAD f.write(\u0026#34;dead ?????????????????\\n\u0026#34;) continue i_instr = inst[bc[0]] # instruction #################################### # NOTE THAT SOME INSTRUCTIONS AREN\u0026#39;T USED, SO I WILL NOT WRITE \u0026lt;IF STATEMENTS\u0026gt; FOR THEM #################################### if i_instr == \u0026#39;add\u0026#39; or i_instr == \u0026#39;xor\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}], reg[{bc[2]}], reg[{bc[3]}]\u0026#34; elif i_instr == \u0026#39;addi\u0026#39; or i_instr == \u0026#39;muli\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}], reg[{bc[2]}], {bc[3]}\u0026#34; elif i_instr == \u0026#39;inv\u0026#39;: final_res = i_instr, bc[1:] elif i_instr == \u0026#39;push\u0026#39; or i_instr == \u0026#39;pop\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}]\u0026#34; elif i_instr == \u0026#39;mov\u0026#39;: temp = 0 if len(bc) \u0026lt;= 2 else int( \u0026#34;\u0026#34;.join(f\u0026#34;%.2x\u0026#34; % i for i in bc[2:][::-1]) , 16) if len(bc) \u0026lt;= 1: temp = 0 final_res = f\u0026#34;{i_instr} reg[{bc[1]}], {temp}\u0026#34; elif i_instr == \u0026#39;exit\u0026#39;: final_res = f\u0026#34;{i_instr}()\u0026#34; elif i_instr == \u0026#39;putc\u0026#39;: p = \u0026#34;\u0026#34; # to_print if bc[1] == 10: p = \u0026#39;\\\\n\u0026#39; elif bc[1] == 32: p = \u0026#39;SPACE\u0026#39; else: p = chr(bc[1]) final_res = i_instr + \u0026#34; \u0026#34; + p elif i_instr == \u0026#39;je\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}], reg[{bc[2]}] ? {bc[3] * 6} : {i + 6}\u0026#34; elif i_instr == \u0026#39;jle\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}], reg[{bc[2]}] ? {bc[3] * 6} : {i + 6}\u0026#34; elif i_instr == \u0026#39;store\u0026#39;: final_res = f\u0026#34;{i_instr} mem[reg[{bc[1]}]], reg[{bc[2]}]\u0026#34; elif i_instr == \u0026#39;load\u0026#39;: final_res = f\u0026#34;{i_instr} reg[{bc[1]}], mem[reg[{bc[2]}]]\u0026#34; elif i_instr == \u0026#39;input\u0026#39;: final_res = f\u0026#34;{i_instr} store in reg[{bc[1]}]\u0026#34; else: final_res = f\u0026#34;{i_instr} NOT FOUND ???????????? \u0026#34; + str(bc) f.write(f\u0026#34;{i}: {final_res}\\n\u0026#34;) putc \u0026#34;[Main Vessel Terminal]\\n\r\u0026lt; Enter keycode \\n\r\u0026lt; \u0026#34;\r252: mov reg[30], 4000\r258: mov reg[28], 0\r264: mov reg[29], 17\r270: input store in reg[25]\r276: store mem[reg[30]], reg[25]\r282: addi reg[30], reg[30], 1\r288: addi reg[28], reg[28], 1\r294: jle reg[28], reg[29] ? 270 : 300\r300: mov reg[30], 4100\r306: mov reg[31], 4000\r312: mov reg[28], 0\r318: mov reg[29], 10\r324: mov reg[27], 169\r330: mov reg[23], 0\r336: load reg[25], mem[reg[30]]\r342: load reg[24], mem[reg[31]]\r348: xor reg[25], reg[25], reg[27]\r354: je reg[25], reg[24] ? 468 : 360\r360: putc \u0026#34;Unknown keycode!\\n\u0026#34;\r462: exit()\r468: addi reg[30], reg[30], 1\r474: addi reg[31], reg[31], 1\r480: addi reg[28], reg[28], 1\r486: jle reg[28], reg[29] ? 336 : 492\r492: mov reg[15], 0\r498: push reg[15]\r504: push reg[15]\r510: push reg[15]\r516: (\u0026#39;inv\u0026#39;, [101, 3])\r522: mov reg[16], 0\r528: je reg[31], reg[16] ? 648 : 534\r534: putc \u0026#34;Terminal blocked!\\n\u0026#34;\r642: exit()\r648: mov reg[30], 119\r654: muli reg[30], reg[30], 6\r660: mov reg[28], 0\r666: mov reg[29], 1500\r672: mov reg[27], 69\r678: load reg[25], mem[reg[30]]\r684: xor reg[25], reg[25], reg[27]\r690: store mem[reg[30]], reg[25]\r696: addi reg[30], reg[30], 1\r702: addi reg[28], reg[28], 1\r708: jle reg[28], reg[29] ? 678 : 714\rdead ?????????????????\rdead ?????????????????\rdead ????????????????? After decompiling the byte code we got the following:\nIt first ask for the keycode Loop through to check if the user input greater than or equal 17 and it store the user input in address 4000 in memory Load the values in memory address 4100 and store it in reg[25] (it seems that itâ€™s the key) and XOR it with the value in reg[27] which is 169 and compare it with our input so letâ€™s get the value in memory 4100\n1 2 3 reg_24 = \u0026#34;CA 99 CD 9A F6 DB 9A CD F6 9C C1 DC DD CD 99 DE C7\u0026#34;.split(\u0026#34; \u0026#34;) flag = \u0026#34;\u0026#34;.join( [chr( 169 ^ int(i, 16) ) for i in reg_24] ) print(flag) # c0d3_r3d_5hutd0wn 648: mov reg[30], 119\r654: muli reg[30], reg[30], 6\r660: mov reg[28], 0\r666: mov reg[29], 1500\r672: mov reg[27], 69\r678: load reg[25], mem[reg[30]]\r684: xor reg[25], reg[25], reg[27]\r690: store mem[reg[30]], reg[25]\r696: addi reg[30], reg[30], 1\r702: addi reg[28], reg[28], 1\r708: jle reg[28], reg[29] ? 678 : 714\rdead ?????????????????\rdead ?????????????????\rdead ????????????????? EDIT THIS PART IN THE SCRIPT 1 2 if bc[0] \u0026gt;= 0x19: # DEAD bc = [(i ^ 0x45) for i in bc if i != 0] \u0026nbsp;\u0026nbsp;\rLetâ€™s continue our analysis for the byte code. reg[30] = 119 then reg[30] *= 6 which is 714 and load this to reg[25]\rIt XOR with reg[27] which is 69 and store the byte code in address 1500. Thatâ€™s why we got a dead ?????? code\nRESULT 1020: mov reg[30], 4400\r1026: mov reg[31], 4600\r1032: mov reg[26], 0\r1038: mov reg[27], 35\r1044: load reg[20], mem[reg[30]]\r1050: push reg[31]\r1056: pop reg[15]\r1062: add reg[15], reg[15], reg[28]\r1068: load reg[16], mem[reg[15]]\r1074: xor reg[20], reg[20], reg[16]\r1080: store mem[reg[30]], reg[20]\r1086: addi reg[26], reg[26], 1\r1092: addi reg[30], reg[30], 1\r1098: jle reg[26], reg[27] ? 1044 : 1104 **; loop from 0 -\u0026gt; 35**\r1104: addi reg[28], reg[28], 1\r1110: jle reg[28], reg[29] ? 918 : 1116\r1116: mov reg[30], 4400\r1122: mov reg[31], 4700\r1128: mov reg[26], 0\r1134: mov reg[27], 35\r1140: load reg[15], mem[reg[30]]\r1146: load reg[16], mem[reg[31]]\r1152: je reg[15], reg[16] ? 1206 : 1158 **; loop from 0 -\u0026gt; 35**\r1158: putc Wrong!\\n\r1200: exit()\r1206: addi reg[26], reg[26], 1\r1212: addi reg[30], reg[30], 1\r1218: addi reg[31], reg[31], 1\r1224: jle reg[26], reg[27] ? 1140 : 1230\r1230: putc Acess granted, shutting down!\\n\r1416: exit()\rfinish ????????????????????? 1020: mov reg[30], 4400\r1026: mov reg[31], 4600\r1032: mov reg[26], 0\r1038: mov reg[27], 35\r1044: load reg[20], mem[reg[30]]\r1050: push reg[31]\r1056: pop reg[15]\r1062: add reg[15], reg[15], reg[28]\r1068: load reg[16], mem[reg[15]]\r1074: xor reg[20], reg[20], reg[16]\r1080: store mem[reg[30]], reg[20]\r1086: addi reg[26], reg[26], 1\r1092: addi reg[30], reg[30], 1\r1098: jle reg[26], reg[27] ? 1044 : 1104 ; loop from 0 -\u0026gt; 35\r1104: addi reg[28], reg[28], 1\r1110: jle reg[28], reg[29] ? 918 : 1116\r1116: mov reg[30], 4400\r1122: mov reg[31], 4700\r1128: mov reg[26], 0\r1134: mov reg[27], 35\r1140: load reg[15], mem[reg[30]]\r1146: load reg[16], mem[reg[31]]\r1152: je reg[15], reg[16] ? 1206 : 1158 ; loop from 0 -\u0026gt; 35\r1158: putc Wrong!\\n\r1200: exit()\r1206: addi reg[26], reg[26], 1\r1212: addi reg[30], reg[30], 1\r1218: addi reg[31], reg[31], 1\r1224: jle reg[26], reg[27] ? 1140 : 1230\r1230: putc Acess granted, shutting down!\\n\r1416: exit()\rfinish ????????????????????? \u0026nbsp;\u0026nbsp;\rAgain it check for the user input if itâ€™s greater than or equal 36 it will continue else it will go back for the input [flag length is 36] Store these values reg[20] = mem[4400] â†’ load the value in offset 4400 to reg[20] (which is user input address) reg[21] = mem[4500] â†’ load the value in offset 4500 to reg[21] (???) It seems that it store the input of the user and then go to the next for loop (nested for loop) and swap the value of the user_input with user_input[???] 1 2 3 for i in user_input: for j in range(0, 36): swap(user_input[i], user_input[???[j]]) reg[31] = mem[4600] â†’ load the value in offset 4600 to reg[20] (???) It then XOR with the value in the offset 4600 and compare it with the value in offset 4700 1 2 3 4 5 for i in range(0,36): for j in range(0,36): swap(user_input[j], user_input[sbox[j]]) for j in range(0,36): user_input[j] = user_input[j] ^ xor_val[i] we can decrypt it easily and get the flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 f = open(\u0026#34;bin\u0026#34;, \u0026#34;rb\u0026#34;).read()[3:] # escape the first three bytes: UwU sbox = bytearray(f[4500:][:36]) xor = bytearray(f[4600:][:36]) enc = bytearray(f[4700:][:36]) for i in range(35,-1,-1): for j in range(36): enc[j] ^= xor[i] for j in range(35,-1,-1): enc[j], enc[sbox[j]] = enc[sbox[j]], enc[j] print(enc) ðŸš© HTB{5w1rl_4r0und_7h3_4l13n_l4ngu4g3} ","description":"ðŸª 66 Million Years Agoâ€¦ All started million years ago in a distant planet, home to a parasitic alien species. Their planet was threatened by a black hole and were searching solutions to survive.","id":3,"section":"ctfs","tags":["writeUps","REV","angr","Symbolic Execution"],"title":"HTB Cyber Apocalypse","uri":"https://s00ra.github.io/ctfs/cyberapocalypse/"},{"content":"Sample: 76840fa18df8764afb51f1aa6da10ff65f1bdfe434dc988917380fa31fbe3a73 Introduction Malware is often packed in a way that makes it difficult to understand the code written by the author. Actors behind the malware take the time to obfuscate it so that it is not easy for someone to quickly identify what it does and how to stop it. Depending on the skill level of the malware authors, they may use pre-existing tools such as UPX, or create their own packer. In our case, they are using VM-Protect but not configuring it correctly, which could result in easy unpacking.\nMy Approach When it comes to unpacking VM-Protect or most types of malware, there are two methods available.\nThe first involves running the malware in a sandbox and searching for API calls. By setting a breakpoint, the packed malware can be revealed. The second method involves suspending the process using Process Hacker and attaching a debugger while the malware is running. First Method Using Sandbox As I explored the sample on hybrid analysis, I noticed that the malware tries to sleep for a long time. So I decided to add a breakpoint at the sleep function call.\n\u0026nbsp;\rFirst, we can open our sample in x32dbg and run it until we reach the entry point. From there, we can set a breakpoint at the sleep function and continue until we hit our breakpoint, and we will have unpacked malware. Once we have completed this step, we can use VMPImportFixer tools to resolve any obfuscated API calls that may be present in the VMProtect binary.\nOur file size and import dictionary have increased beyond the packed malware.\nSecond Method Execute the malware normally and then suspend the process and attach the process to x32dbg\nIf the sample is an MSVC binary, the entry point will contain boilerplate code (fixed code) common to all MSVC binaries. Because this code is common, we can search for the Security Cookie Constant in memory and identify the entry point. This allows us to set a breakpoint on the entry point and obtain a cleaner sample dump. We cannot use this trick if this is not an MSVC binary.\n1\r2\r3\r4\r5\r1ï¸âƒ£ Thatâ€™s a boilerplate code you can find in any C++ binary. You can compile your hello world binary 32-bit using visual studio and get the same byte code as the picture. Open the C++ binary in IDA and get the bytecode 4E E6 40 BB\n2ï¸âƒ£ Go to the .text section, follow in Dump\n3ï¸âƒ£ After that right click choose â€œFind Patternâ€ and search for those bytecodes\n4ï¸âƒ£ After that set a Hardware Breakpoints on the it cause this memory doesnâ€™t exists as itâ€™s written at runtime\nNote: we just stopped the execution somewhere; part of this program already ran, and this will miss our dump as there would be values not being necessary set, so we want to dump as close as the entry point.\r5ï¸âƒ£ Finally, rerun the program and will hit our hardware breakpoint. Letâ€™s check the call stack, and we will find our main entry point. Letâ€™s dump our malware using VMPImportFixer\nConclusion In conclusion, unpacking malware can be a challenging task due to the various obfuscation techniques employed by malware authors. However, by employing the appropriate methods, it is possible to reveal the underlying code and understand the functionality of the malware.\n","description":"Malware is often packed in a way that makes it difficult to understand the code written by the author. Actors behind the malware take the time to obfuscate it so that.......","id":4,"section":"malware-reports","tags":["REV","Tips \u0026 Tricks","malware analysis"],"title":"Unpacking VMProtect","uri":"https://s00ra.github.io/malware-reports/vmprotect/"},{"content":"â¬‡ï¸ Challenge Link: R3V3RS3 ME Intro Welcome to my blog, today we will delve into the intricacies of a reverse engineering challenge from Cybertalent, specifically, the challenge known as R3V3RS3 ME. This challenge presents us with a .jar file, and as any reverse engineer would know, the first step in solving this challenge is to decompile the file. To accomplish this, we will use the online decompiler\nWe will be presented with a Java file upon obtaining the decompilation results. We can then proceed to open and analyze the file.\rBriefly I have included an image to give a brief description of the program\u0026rsquo;s functionality.\nEncryption The program begins by prompting the user for the key and message. It is important to note that the key must not contain any repeated characters, and the message should be only composed of both [a-z] and digits [0-9]. Next, the \u0026ldquo;col\u0026rdquo; variable, a 2-D array, is created and its size is set using a specific formula within the prepareColumns() method. Then, the encryption process begins, the program loops through each character of the message, and determines their position in the \u0026lsquo;grid\u0026rsquo; array, which is defined in the Messedup() class. Each character is then represented in the encryption text by two characters. For example, if the character is \u0026ldquo;A\u0026rdquo;, the position in the \u0026lsquo;grid\u0026rsquo; array is (4, 3). The program then takes the value 4 and looks up the corresponding character in the morse array, which is \u0026lsquo;Y\u0026rsquo; and value 3 which is \u0026lsquo;G\u0026rsquo; in morse. Therefore, \u0026ldquo;A\u0026rdquo; will be represented as \u0026ldquo;YG\u0026rdquo;. After that do some sort operation to colAlpha. Finally, the resulting encrypted text is represented in the \u0026lsquo;colAlpha\u0026rsquo; variable and printed as the encryption result.â€\nFor example if the key is â€œtesâ€ and msg is â€œhelloâ€,\nthe value of nb will be [4, 3, 3] thatâ€™s mean the col size is (max(nb), len(key)) message to encrypt is â€œHELLOâ€ after mapping the value of message in grid then get the value in morse array the final value will be GG XK KX KX DG grid = [\n[\u0026lsquo;F\u0026rsquo;, \u0026lsquo;T\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;0\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;L\u0026rsquo;],\n[\u0026lsquo;J\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;O\u0026rsquo;, \u0026lsquo;S\u0026rsquo;, \u0026lsquo;3\u0026rsquo;],\n[\u0026lsquo;7\u0026rsquo;, \u0026lsquo;V\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;M\u0026rsquo;, \u0026lsquo;I\u0026rsquo;],\n[\u0026lsquo;W\u0026rsquo;, \u0026lsquo;U\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;H\u0026rsquo;, \u0026lsquo;K\u0026rsquo;, \u0026lsquo;X\u0026rsquo;],\n[\u0026lsquo;5\u0026rsquo;, \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;N\u0026rsquo;, \u0026lsquo;R\u0026rsquo;],\n[\u0026lsquo;E\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;G\u0026rsquo;, \u0026lsquo;T\u0026rsquo;, \u0026lsquo;9\u0026rsquo;]\n] for example â€œHâ€ position in grid is (3, 3) morse = [\u0026lsquo;K\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;I\u0026rsquo;, \u0026lsquo;G\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Xâ€™] the value will be GG and so on.. col will be like so the value of col will be GKKG GKX XXD (READ COLUMN BY COLUMN) then we need to sort it to get colAlpha the key is â€œtesâ€ if we sort it the result will be â€œestâ€ and we do sort operation to col as the key is sorted thatâ€™s mean colAlpha = GKX XXD GKKG finally our encryption text is colAlpha (enc = GK XX XD GK KG) SOLVE Finally, I will provide you with the code solution for this challenge. By reading through the comments, you can gain a deeper understanding of the code and its purpose. This will be helpful for you to understand the solution.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 import numpy as np from itertools import combinations from string import printable from itertools import permutations grid = [ [\u0026#39;F\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;L\u0026#39;], [\u0026#39;J\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;3\u0026#39;], [\u0026#39;7\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;I\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;5\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;R\u0026#39;], [\u0026#39;E\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;9\u0026#39;] ] morse = [\u0026#39;K\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;X\u0026#39;] # same functionality as prepareColumns() def calc_nb(key_len, cipher_len): nbPerCol = cipher_len // key_len # col_len is key_len actually nb = [nbPerCol for i in range(key_len)] for i in range(cipher_len - key_len * nbPerCol): # where the value in range is \u0026#34;reminder\u0026#34; nb[i] += 1 return nb def unsort(key, enc): sorted_key = \u0026#34;\u0026#34;.join(sorted(key)) key_dic = {} # we need to make it like {original_pos: pos_after_sort, original_pos: pos_after_sort, ..} for i in range(len(key)): key_dic[i] = sorted_key.find(key[i]) unsorted_enc = [type(enc[i])]*len(enc) for k, val in key_dic.items(): unsorted_enc[val] = enc[k] return unsorted_enc def unsort_cipher(key, cipher): sorted_key = \u0026#34;\u0026#34;.join(sorted(key)) cipher_dic = {} for i, val in enumerate(sorted_key): cipher_dic[val] = cipher[i] new_cipher = [] for i in key: new_cipher.append(cipher_dic[i]) return new_cipher def dec(key, cipher): ############### FIRST GET COL # first we need the cipher to be in format of nb for example [4, 3, 3] # but NOTES THAT value after split operation is sorted in encrypted cipher so we have nb like [3 3 4] for example # so we need to unsort the \u0026#34;nb\u0026#34; and then reshape the cipher # so we need to [calculate the value of nb - unsort nb depend on key - then edit cipher] nb = calc_nb(len(key), len(cipher)) # in prepareColumns the len passed is (len_msg*2) which is the same as cipher cause msg_len = cipher / 2 # reposition the value of nb (unsort it) unsort_nb = unsort(key, nb) # cipher HERE EQUAL \u0026#34;colAlpha\u0026#34; cipher = [\u0026#34;\u0026#34;.join(i) for i in np.array_split(list(cipher), np.cumsum(unsort_nb)[:-1])] # reshape the cipher # cipher HERE EQUAL \u0026#34;col\u0026#34; cipher = unsort_cipher(key, cipher) ############### SECOND ORDER CIPHER (COL) CORRECTLY # if we notice that the program calculate the col as the following # if we have text \u0026#34;ahmed\u0026#34; and mappend in morse to be \u0026#34;YG GG IY XK DI\u0026#34; \u0026#39;\u0026#39;\u0026#39; REMEMBER nb = [4, 3, 3] then the value of col (where the key len is 3) will be Y G G G I Y X K D I where it fill from left to right until len of 3 so \u0026#34;Y G G\u0026#34; and move to the next line and so on \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; then it read it like YGXI GIK GYD =\u0026gt; col value \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; so to get the original value back we need to do the following [create a 2d array where we fill column first with the value - then read each row] \u0026#39;\u0026#39;\u0026#39; col = np.full((max(nb), len(key)), \u0026#34;?\u0026#34;, dtype=str) str_cipher = \u0026#34;\u0026#34;.join(cipher) c, k = 0, 0 # create a 2d array where we fill column first with the value for i in nb: for j in range(i): col[j][k] = str_cipher[c] c += 1 k += 1 # then read each row (read 2d array normally) final_res = \u0026#34;\u0026#34; for i in range(col.shape[0]): for j in range(col.shape[1]): if col[i][j] == \u0026#34;?\u0026#34;: continue else: final_res += col[i][j] ############### THIRD GET TWO CHAR IN CIPHER - GET POSITION IN MORSE - MAP IT IN GRID haha_got_the_text = \u0026#34;\u0026#34; for i in range(0, len(final_res), 2): two_char = final_res[i:i+2] x, y = morse.index(two_char[0]), morse.index(two_char[1]) haha_got_the_text += grid[x][y] return haha_got_the_text cipher = \u0026#34;XY XY XG IY IY XX YG KY XD XY XK DX DY DX YX DX YY IY DY DD XD YY KD XI XX YG\u0026#34;.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) # NOW LET\u0026#39;S START A SHITTY BRUTE-FORCE, HMMMMMMMMM :( with open(\u0026#34;all_possible_pt.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: for i in [\u0026#39;A\u0026#39;, \u0026#39;AB\u0026#39;, \u0026#39;ABC\u0026#39;, \u0026#39;ABCD\u0026#39;, \u0026#39;ABCDE\u0026#39;, \u0026#39;ABCDEF\u0026#39;, \u0026#39;ABCDEFG\u0026#39;]: for j in permutations(i): key = \u0026#34;\u0026#34;.join(j) pt = dec(key, cipher) f.write(f\u0026#34;{key}: {pt}\\n\u0026#34;) ðŸš© R3V3RS33N9IN33RIN9KANB3FUN In Details 1\r2\r3\r4\r5\r6\r7\rThe main function starts by asking the user for a key and then creates a new instance of the Messedup() class and assigns it to a variable called â€œspaghettiâ€. The variable â€œkeyâ€ is passed as an argument to the constructor of the Messedup() class, which initializes the grid variable and sets the key variable to the passed in key. â€œspaghettiâ€ variable can be used to call methods of the Messedup() class, such as â€œencodeâ€ method. Messedup() also do some operation and then return setKey(key).\nAfter that, the main function asks the user for a message to encrypt and assigns it to a variable called \u0026ldquo;msg\u0026rdquo;. The \u0026ldquo;msg\u0026rdquo; variable is then passed as an argument to the â€œencodeâ€ method of the â€œspaghettiâ€ object. The encode method performs several operations, such as calling the prepareColumns(), msgToProcess(), and findPos() methods, before returning the final encrypted output. The main function then prints the encrypted output and the encrypted flag\nNow that we have a general understanding letâ€™s breaking down the logic and operations of each function.\nMoving to Messedup() class, we can observe that the class initializes an ArrayList, \u0026lsquo;al\u0026rsquo;, containing a set of characters {\u0026lsquo;9\u0026rsquo;, \u0026lsquo;T\u0026rsquo;, \u0026lsquo;G\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;R\u0026rsquo;, \u0026lsquo;N\u0026rsquo;, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;P\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;X\u0026rsquo;, \u0026lsquo;K\u0026rsquo;, \u0026lsquo;H\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;U\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;I\u0026rsquo;, \u0026lsquo;M\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;V\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;S\u0026rsquo;, \u0026lsquo;O\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;J\u0026rsquo;, \u0026lsquo;L\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;0\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;T\u0026rsquo;, \u0026lsquo;F\u0026rsquo;, \u0026lsquo;Zâ€™}. Additionally, a 2-dimensional array, \u0026lsquo;grid\u0026rsquo;, is declared with a length of 6x6, corresponding to the length of Morse variable. The class then proceeds to execute a nested loop, which iterates over the elements of \u0026lsquo;al\u0026rsquo; and assigns them to the corresponding positions within \u0026lsquo;grid\u0026rsquo;.â€\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 al = [\u0026#39;9\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;Z\u0026#39;] grid = [[\u0026#39;?\u0026#39; for i in range(6)] for j in range(6)] index = 35 for i in range(6): for j in range(6): if len(al) != 0: grid[i][j] = al.pop(index) # or al[index] index -= 1 \u0026#39;\u0026#39;\u0026#39; grid = [ [\u0026#39;F\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;L\u0026#39;], [\u0026#39;J\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;3\u0026#39;], [\u0026#39;7\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;I\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;5\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;R\u0026#39;], [\u0026#39;E\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;9\u0026#39;] ] \u0026#39;\u0026#39;\u0026#39; Next, we will move to setKey() method within the Messedup() class. This method performs several operations, including a:\ncheck to verify if the key is empty or not. It also verifies if the key contains unique characters and if not, it returns an empty key. The final operation is defining a private inner class called \u0026ldquo;Column\u0026rdquo; within another class. The Column class has a constructor that takes in a single char parameter called \u0026ldquo;header\u0026rdquo; and assigns it to the \u0026ldquo;header\u0026rdquo; instance variable of the Column object. The class also has several methods such as \u0026ldquo;setSize\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;getChar\u0026rdquo;, \u0026ldquo;toString\u0026rdquo;, and \u0026ldquo;compareTo\u0026rdquo;. Now, we will examine the encode() method within the Messedup() class. This method first passes the string to be encrypted, as an argument with True boolean value, to the msgToProcess() function.\nWe will now analyze the msgToProcess() method in detail.\nCheck if the input string â€œstrâ€ is null or if the key length is 0 it will immediately return a new empty char array The method will first convert the input string to uppercase using the â€˜toUpperCase()â€™, then convert the resulting string to an array of characters using â€˜toCharArray()â€™, and assigns it to the \u0026ldquo;charArray\u0026rdquo; variable. Then, the method will iterate over the \u0026ldquo;charArray\u0026rdquo; variable, and for each character, it will check if the character is between \u0026lsquo;A\u0026rsquo; and \u0026lsquo;Z\u0026rsquo; or between \u0026lsquo;0\u0026rsquo; and \u0026lsquo;9\u0026rsquo; and will append the character to the StringBuilder \u0026ldquo;sbâ€ After that, the method will convert the StringBuilder \u0026ldquo;sb\u0026rdquo; to an array of characters using the â€˜toString().toCharArray()â€™ and assigns it to the \u0026ldquo;digit\u0026rdquo; variable. Then return the digit value to digit in encode() 1 2 3 4 5 6 7 8 def msgToProcess(str_v): # coding always True charArray = [i.upper() for i in str_v] sb = [] for c in charArray: val = ord(c) if (val \u0026gt;= ord(\u0026#39;A\u0026#39;) and val \u0026lt;= ord(\u0026#39;Z\u0026#39;)) or (val \u0026gt;= ord(\u0026#39;0\u0026#39;) and val \u0026lt;= ord(\u0026#39;9\u0026#39;)): sb.append(c) return \u0026#34;\u0026#34;.join(sb) Then prepareColumns\nTo better understand the functionality of the prepareColumns() method, let\u0026rsquo;s provide an example.\nIf the input message is \u0026lsquo;hello\u0026rsquo; and the key is \u0026lsquo;key\u0026rsquo;. In this case, the input to the prepareColumns() method is 10, which is the length of the message \u0026lsquo;hello\u0026rsquo; multiplied by 2.\nThe variable \u0026ldquo;nbPerCol\u0026rdquo; is calculated by dividing the input value by the length of the \u0026lsquo;col\u0026rsquo; array, which is 3 in this case. So, nbPerCol = 10/3 = 3.333. Since it is an integer variable, the result will be rounded down to 3.\nAn int array \u0026ldquo;nb\u0026rdquo; with the same length as the \u0026lsquo;col\u0026rsquo; array is initialized. This array is then populated by looping through its values and assigning the value of nbPerCol to each element. The resulting array will be nb = [3, 3, 3].\nThe variable \u0026ldquo;reminder\u0026rdquo; is calculated by taking (10 - 3*3) = 1. Then a loop from j=0 until reminder, the value of nb = [4, 3, 3]\nFinally, the last loop will make the size of \u0026lsquo;col\u0026rsquo; array equal\n(max(nb), len(key))\nFinally, we will examine the findPos() method within the Messedup() class. This method takes a character as an argument and searches for its position in the 2-dimensional array \u0026lsquo;grid\u0026rsquo;. Once the position is found, it is returned as a set of coordinates.\n","description":"Developer thinks he can code better than us, lets prove him wrong! CYBERTALENTS","id":5,"section":"ctfs","tags":["writeUps","REV"],"title":"Cyber Talents - R3V3RS3 ME","uri":"https://s00ra.github.io/ctfs/r3v3rs3me/"},{"content":"Download link S01den\u0026rsquo;s cube Intro Welcome to my blog! Today, we will be diving into the world of solving a Rubik's cube, as represented by the crackme. As a huge fan of solving Rubik's cube, I was immediately drawn to this particular crackme challenge. I own a 3x3 Rubik's cube and have even been able to solve it in under 50 seconds ðŸ˜Š\nBefore diving into the reverse engineering process, let's first take a look at the file we will be working with. If we try to run the file and enter any input, we will immediately be presented with the message [!] Bad flag! This is to be expected\nCloser look It's time to take a closer look, so let's launch IDA and open our target file, and see what secrets we can uncover!\rOne of the first things we can do in IDA is to open the Strings view, which will show us all the hard-coded strings that are used in the program. By doing this, we can quickly locate the message [!] Bad flag!, which we encountered when we first ran the program. This is a good starting point, so letâ€™s jump to it.\rNow that we have located the [!] Bad flag! message in the program, let's move on to the main function to begin our analysis. The first thing we notice is that the program takes our input, which must be less than or equal to 99 characters, and then proceeds to loop through each character of the input. This is where the program checks if the input characters match any of the characters BDFLRUbdflru. The program then performs specific operations on a set of bytes defined in the program based on the input character.\rwhich are the basic moves of a Rubik's cube. As a Rubik's cube player, you already know that these symbols represent the Up, Down, Right, Left, Front, and Back moves of a Rubik's cube. Additionally, small symbols represent the vice versa.\rThere are 24 unique values. This tells us that this crackme is related to a 2x2 Rubik's cube. This is because a 2x2 Rubik's cube has 24 total cubes or stickers in total, which means each face has 4 stickers. This is consistent with the 24 unique values we found in the program's code.\rEach value is assigned to a different value. Upon further examination, we find that there are only 6 unique values [0x6f, 0x62, 0x76, 0x6a, 0x42, 0x72], which are related to the 4 colors in a 2x2 Rubik's cube (red, orange, blue, green, white, yellow).\rIt becomes clear that the program is checking the input against a scrambled 2x2 Rubik's cube. This means that we need to find the correct sequence of moves that will solve the scrambled cube. Solution To solve the crackme, we first need to understand the position of the bytes in the program and how they relate to the physical 2x2 Rubik's cube. We can also assign color to each value like cube = {0x6f: â€˜orangeâ€™, 0x72: â€˜redâ€™, 0x6a: â€˜greenâ€™, 0x42: â€˜whiteâ€™, 0x76: â€˜yellowâ€™, 0x62: â€˜blueâ€™}. (OR YOU CAN REPLACE WHITE TO YELLOW \u0026 GREEN TO BLUE \u0026 RED TO ORANGE)\nIn order to understand the physical location of the bytes, we can take advantage of the symbols represented in the switch case statements in the program. These symbols likely correspond to the basic moves of the Rubik's cube, such as Up, Down, Right, Left, Front, and Back. By analyzing the program's switch case statements, we can determine how the bytes are moved and manipulated in relation to the cube.\nBYTE_NUM\rVALUE\rCOLOR\rbyte_4049\r0x6F\rorange\rbyte_404A\r0x62\rblue\rbyte_404B\r0x76\ryellow\rbyte_404C\r0x62\rblue\rbyte_404D\r0x62\rblue\rbyte_404E\r0x6A\rgreen\rbyte_404F\r0x42\rwhite\rbyte_4050\r0x72\rred\rbyte_4051\r0x6F\rorange\rbyte_4052\r0x72\rred\rbyte_4053\r0x76\ryellow\rbyte_4054\r0x6A\rgreen\rbyte_4055\r0x42\rwhite\rbyte_4056\r0x76\ryellow\rbyte_4057\r0x72\rred\rbyte_4058\r0x6A\rgreen\rbyte_4059\r0x42\rwhite\rbyte_405A\r0x72\rred\rbyte_405B\r0x76\ryellow\rbyte_405C\r0x6A\rgreen\rbyte_405D\r0x42\rwhite\rbyte_405E\r0x6F\rorange\rbyte_405F\r0x62\rblue\rEx1\rEx2\rConclusion\rEx1 For example, when the case is 'L', we can notice that the program is swapping several bytes in the array which indicates that the left face of the cube is being rotated.\nEx2 For example, when the case is 'R', we can notice that the program is swapping several bytes in the array which indicates that the right face of the cube is being rotated.\nConclusion As you continue analyzing the switch cases and the byte movements, you will be able to map all the byte positions in the program to the physical positions of the stickers on the cube. This will give you a clear image of the cube's state and the moves required to solve it.\nOnce we have determined the positions of the bytes in relation to the physical 2x2 Rubik's cube, you can use online tools like cube solver Great, now that you have found the correct keys using the website, we can test your program by entering the keys as the input.\nBy inputting the correct keys, the program should verify the input and confirm that it is correct.\n","description":"Find a correct flag!","id":6,"section":"crackmes","tags":["crackmes","Unix/linux","REV"],"title":"S01den's cube","uri":"https://s00ra.github.io/crackmes/s01dens-cube/"},{"content":"Download link X0rb0y Welcome to my latest adventure! Today, I\u0026rsquo;ll be taking you through the process of solving a crackme challenge that had me stumped for hours. The challenge was a Windows executable, and the goal was simple: find the correct key to unlock the program. But as with all CTF challenges, the solution was anything but simple.\nThe first thing I did was load the executable into IDA, to take a closer look at the program\u0026rsquo;s inner workings. As I began to analyze the code, I quickly realized that simply entering any key wouldn\u0026rsquo;t work. The program had a specific key length in mind and would reject any input that didn\u0026rsquo;t match that length. So, without further ado, let\u0026rsquo;s dive into it!\nThe program was looking for a specific length of 32 characters. Any input shorter or longer than that would be rejected, and the program would give us message â€œWrong Length!â€ and exit.\nWith the length check out of the way, I moved on to the next step in the program\u0026rsquo;s logic. The next check was to read the first 11 characters of the input and compare it to a hardcoded string \u0026ldquo;Securinets{\u0026quot;. If the input matched the hardcoded string, the program would continue to the next check, if not, the program would exit.\nWith the first 11 characters of the key successfully unlocked, I moved on to the next step of the program\u0026rsquo;s logic. The next 9 characters of the input were read and the program performed a check to ensure that these characters were digits from 0 to 9. If any of the characters failed this check, the program would exit.\n1 2 3 4 5 6 from string import printable for i in printable: if ord(i) - 48 \u0026gt; 9: continue else: print(i) # it will print digits from 0 to 9 and some other characters The next step was to pass these 9 characters to a function called fnv_1a_32() which is a hash function that returns an integer. This integer was then compared to a hardcoded value of -105269403. If the two values matched, the program would proceed to the next step, if not, it would exit.\nThe function starts by initializing a variable called **v3** with the value of **-2128831035**. It then enters a loop that iterates through each character of the input. Within the loop, it performs a bitwise XOR operation between v3 and the ASCII value of the current character. The result of this operation is then multiplied by the value of 16777619 and stored back into v3. This process continues until the loop has iterated through all the characters of the input. The final value of v3 is then returned by the function.\rOne of the key steps in solving this challenge was finding the correct 9-character input that only contains digits and satisfies the equation produced by the fnv_1a_32() function.\nUsing Z3 was a much more efficient approach, and it allowed me to find the correct input in a fraction of the time it would have taken using a brute-force approach.\nTo begin solving this challenge using Z3, the first step is to define the 9-digit input as a BitVector and add the constraints that the input must satisfy in binary.\n1 2 3 4 5 6 7 8 9 from z3 import * # z3.Solver() designed to determine whether a set of constraints has a solution or not, and if it does, it can return one or more solutions. # Optimize() designed to find the best solution among a set of constraints solver = Optimize() # we need to genereate a 9 character password = [BitVec(\u0026#34;c_%i\u0026#34; % i ,32) for i in range(9)] for char in password: # character constrains solver.add(And(char - 48 \u0026gt;= 0, char - 48 \u0026lt;= 9)) In this code, we are defining the variable v3 as a BitVector of size 32. This variable v3 will be used to represent the result of the fnv_1a_32(). We also define a variable a with the value of 16777619, which is a constant used in the fnv_1a_32() function. Next, we are adding a constraint to the Z3 solver that represents the logic in the if condition\n1 2 3 v3 = BitVec(\u0026#34;v3\u0026#34;, 32) a = 16777619 solver.add(v3 == -105269403) The simulate the loop in the function fnv_1a_32() but in z3\n1 2 3 4 v3 = -2128831035 for i in password: v3 = 16777619 * (i ^ v3) solver.add(v3 == -105269403) With all the pieces in place, it was finally time to put my Z3 script to the test.\n1 2 3 4 5 6 7 if solver.check() == sat: print(\u0026#34;yes\u0026#34;) password_sol = [solver.model()[char].as_long() for char in password] return \u0026#34;\u0026#34;.join([chr(i) for i in password_sol]) else: print(\u0026#34;no sol\u0026#34;) return 0 With the script finished running and the results was 806470850. so until know we have input Securinets{806470850\nWith the first and second parts of the key, it was time to move on to the final stage of the challenge: checking the last 12 characters of the input.\nI found out that the program passed the last 12 characters of the input through a function called \u0026ldquo;rot\u0026rdquo; before comparing it with the string \u0026ldquo;_Q3eM3tT1t6}\u0026rdquo;.\nThe rot() function was a simple rotation function that shifted the letters in the input by a certain number of positions. It took two parameters, the string to be rotated, and the amount of rotation.\rOne important thing to note is that the rotation didn\u0026rsquo;t happen on special characters or numbers, it only happened on the alphabetic characters a-z and A-Z.\nThere are a few different ways to reverse the rot() function and find the correct input. One option is to use a tool like CyberChef. Another option is to write a python script to brute-force the characters.\nHowever, in this case, I used the easy and fast way ðŸ™‚.\n\u0026nbsp;\rAnd with that, the challenge was finally complete. The correct input was \u0026ldquo;Securinets{806470850_K3yG3nN1n6}\u0026rdquo;, and it was accepted by the program.\nI would like to thank you for reading this blog post and following along on my journey. I am happy to have reached the end and I hope you enjoyed it as much as I did. If you have any questions or feedback, please feel free to reach out to me 50r4.\n","description":"Just find the right password to crack it !","id":7,"section":"crackmes","tags":["crackmes","Windows","REV"],"title":"X0rb0y","uri":"https://s00ra.github.io/crackmes/x0rb0y/"}]